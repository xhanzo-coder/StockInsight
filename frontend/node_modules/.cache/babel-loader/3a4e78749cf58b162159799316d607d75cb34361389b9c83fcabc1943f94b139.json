{"ast":null,"code":"var _process$env$REACT_AP;\n/**\n * 认证服务\n * 处理用户登录、注册、令牌管理等功能\n * 增强的错误处理和重试机制\n */\n\nimport axios from 'axios';\nimport { message } from 'antd';\nimport { tokenManager } from './api';\n\n// 认证API基础URL\n// const AUTH_API_URL = 'http://localhost:5000/api/auth';\n\n// 将硬编码URL改为使用环境变量\nconst AUTH_API_URL = ((_process$env$REACT_AP = process.env.REACT_APP_API_BASE_URL) === null || _process$env$REACT_AP === void 0 ? void 0 : _process$env$REACT_AP.replace('/api', '/api/auth')) || 'http://localhost:5000/api/auth';\n\n// 本地存储键\nconst USER_INFO_KEY = 'userInfo';\nconst AUTH_LAST_VERIFIED_KEY = 'auth_last_verified';\n\n// 配置常量\nconst REQUEST_TIMEOUT = 15000; // 请求超时时间（毫秒）\nconst MAX_RETRY_COUNT = 2; // 最大重试次数\nconst RETRY_DELAY = 1000; // 重试延迟（毫秒）\n\n// 创建认证专用的 axios 实例\nconst authApi = axios.create({\n  baseURL: AUTH_API_URL,\n  timeout: REQUEST_TIMEOUT,\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n\n// 请求重试函数\nconst retryAuthRequest = async (config, retryCount = 0) => {\n  try {\n    return await axios(config);\n  } catch (error) {\n    // 只有在网络错误或5xx服务器错误时重试\n    const isNetworkError = !error.response;\n    const isServerError = error.response && error.response.status >= 500;\n    if ((isNetworkError || isServerError) && retryCount < MAX_RETRY_COUNT) {\n      console.log(`认证请求失败，${RETRY_DELAY / 1000}秒后重试 (${retryCount + 1}/${MAX_RETRY_COUNT})`);\n      await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));\n      return retryAuthRequest(config, retryCount + 1);\n    }\n    throw error;\n  }\n};\n\n// 添加请求拦截器 - 自动添加token到请求头\nauthApi.interceptors.request.use(config => {\n  const token = tokenManager.getToken();\n  if (token) {\n    config.headers = config.headers || {};\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n\n  // 添加请求时间戳，用于调试\n  config.headers = config.headers || {};\n  config.headers['X-Request-Time'] = new Date().toISOString();\n\n  // 记录请求信息（调试模式）\n  if (process.env.NODE_ENV === 'development') {\n    var _config$method;\n    console.log(`🔐 认证请求: ${(_config$method = config.method) === null || _config$method === void 0 ? void 0 : _config$method.toUpperCase()} ${config.url}`, {\n      headers: {\n        ...config.headers,\n        Authorization: token ? '已设置' : '未设置'\n      },\n      data: config.data,\n      params: config.params\n    });\n  }\n  return config;\n}, error => {\n  console.error('认证请求拦截器错误:', error);\n  return Promise.reject(error);\n});\n\n// 添加响应拦截器 - 处理token过期\nauthApi.interceptors.response.use(response => {\n  // 记录响应信息（调试模式）\n  if (process.env.NODE_ENV === 'development') {\n    var _response$config$meth;\n    console.log(`✅ 认证响应成功: ${(_response$config$meth = response.config.method) === null || _response$config$meth === void 0 ? void 0 : _response$config$meth.toUpperCase()} ${response.config.url}`, {\n      status: response.status,\n      data: response.data\n    });\n  }\n  return response;\n}, error => {\n  // 获取请求配置和响应\n  const {\n    config,\n    response\n  } = error;\n\n  // 记录错误信息（调试模式）\n  if (process.env.NODE_ENV === 'development') {\n    var _config$method2;\n    console.error(`❌ 认证请求失败: ${config === null || config === void 0 ? void 0 : (_config$method2 = config.method) === null || _config$method2 === void 0 ? void 0 : _config$method2.toUpperCase()} ${config === null || config === void 0 ? void 0 : config.url}`, {\n      status: response === null || response === void 0 ? void 0 : response.status,\n      data: response === null || response === void 0 ? void 0 : response.data,\n      error: error.message\n    });\n  }\n\n  // 处理401错误（未授权，通常是token过期或无效）\n  if ((response === null || response === void 0 ? void 0 : response.status) === 401) {\n    console.warn('认证请求收到401未授权响应');\n\n    // 清除认证相关数据\n    tokenManager.removeToken();\n    localStorage.removeItem(USER_INFO_KEY);\n    localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n\n    // 如果不是验证接口的请求，显示提示并重定向\n    if ((config === null || config === void 0 ? void 0 : config.url) !== '/verify') {\n      message.error('登录已过期，请重新登录');\n\n      // 使用延迟重定向，确保消息能够显示\n      setTimeout(() => {\n        // 保存当前URL，以便登录后返回\n        const currentPath = window.location.pathname;\n        if (currentPath !== '/login') {\n          sessionStorage.setItem('redirectAfterLogin', currentPath);\n        }\n        window.location.href = '/login';\n      }, 1500);\n    }\n  }\n  return Promise.reject(error);\n});\n\n// 用户数据类型\n\n// 登录请求数据\n\n// 注册请求数据\n\n// 认证响应数据\n\n// API 响应格式\n\n// 认证服务类\nexport class AuthService {\n  /**\n   * 用户注册\n   */\n  async register(userData) {\n    try {\n      // 使用重试机制发送请求\n      const response = await retryAuthRequest({\n        method: 'post',\n        url: `${AUTH_API_URL}/register`,\n        data: userData,\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      const data = response.data;\n      if (data.success && data.data) {\n        // 保存令牌 - 后端返回的是token字段\n        tokenManager.setToken(data.data.token);\n\n        // 保存用户信息和验证时间\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(data.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        message.success('注册成功！');\n        return data;\n      } else {\n        message.error(data.message || '注册失败');\n        return data;\n      }\n    } catch (error) {\n      var _error$response, _error$response2, _error$response2$data;\n      console.error('注册失败:', ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data) || error.message);\n\n      // 检查是否为网络错误\n      const isNetworkError = !error.response;\n      if (isNetworkError) {\n        const errorMessage = '网络连接错误，请检查网络连接';\n        message.error(errorMessage);\n        return {\n          success: false,\n          message: errorMessage,\n          networkError: true\n        };\n      }\n      const errorMessage = ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || '注册失败，请重试';\n      message.error(errorMessage);\n      return {\n        success: false,\n        message: errorMessage,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * 用户登录\n   */\n  async login(credentials) {\n    try {\n      console.log('开始登录请求:', credentials);\n      console.log('API URL:', AUTH_API_URL);\n\n      // 使用重试机制发送请求\n      const response = await retryAuthRequest({\n        method: 'post',\n        url: `${AUTH_API_URL}/login`,\n        data: credentials,\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      console.log('登录响应:', response.data);\n      const data = response.data;\n      if (data.success && data.data) {\n        // 保存令牌到localStorage - 后端返回的是token字段\n        tokenManager.setToken(data.data.token);\n\n        // 保存用户信息和验证时间\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(data.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n\n        // 检查是否有登录后重定向路径\n        const redirectPath = sessionStorage.getItem('redirectAfterLogin');\n        if (redirectPath) {\n          console.log(`登录成功，将重定向到: ${redirectPath}`);\n          sessionStorage.removeItem('redirectAfterLogin');\n        }\n        message.success('登录成功！');\n        return data;\n      } else {\n        console.error('登录失败:', data.message);\n        message.error(data.message || '登录失败');\n        return data;\n      }\n    } catch (error) {\n      var _error$response3, _error$response4, _error$response5, _error$response5$data;\n      console.error('登录请求异常:', error);\n      console.error('错误响应:', (_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.data);\n\n      // 检查是否为网络错误\n      const isNetworkError = !error.response;\n      if (isNetworkError) {\n        const errorMessage = '网络连接错误，请检查网络连接';\n        message.error(errorMessage);\n        return {\n          success: false,\n          message: errorMessage,\n          networkError: true\n        };\n      }\n\n      // 处理特定错误\n      if (((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status) === 401) {\n        const errorMessage = '用户名或密码错误';\n        message.error(errorMessage);\n        return {\n          success: false,\n          message: errorMessage,\n          error: error.message\n        };\n      }\n      const errorMessage = ((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : (_error$response5$data = _error$response5.data) === null || _error$response5$data === void 0 ? void 0 : _error$response5$data.message) || '登录失败，请重试';\n      message.error(errorMessage);\n      return {\n        success: false,\n        message: errorMessage,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * 验证令牌\n   */\n  async verifyToken() {\n    try {\n      const token = tokenManager.getToken();\n      if (!token) {\n        console.log('没有找到token，无法验证');\n        return {\n          success: false\n        };\n      }\n      console.log('开始验证token...', token.substring(0, 15) + '...');\n      console.log('Token格式检查:', token.split('.').length === 3 ? '有效' : '无效');\n\n      // 直接检查token是否有效\n      if (!tokenManager.isAuthenticated()) {\n        console.warn('本地token验证失败，可能已过期');\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n        return {\n          success: false\n        };\n      }\n\n      // 检查是否有本地存储的用户信息\n      const storedUserInfo = localStorage.getItem(USER_INFO_KEY);\n      let localUser = null;\n      if (storedUserInfo) {\n        try {\n          localUser = JSON.parse(storedUserInfo);\n          console.log('从本地存储恢复用户信息:', localUser);\n        } catch (e) {\n          console.error('解析本地用户信息失败:', e);\n        }\n      }\n\n      // 使用重试机制发送请求\n      console.log(`发送验证请求到: ${AUTH_API_URL}/verify`);\n      const response = await retryAuthRequest({\n        method: 'get',\n        url: `${AUTH_API_URL}/verify`,\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        },\n        timeout: 5000 // 降低超时时间，加快验证速度\n      });\n\n      // 请求拦截器会自动添加Authorization头\n      const data = response.data;\n      console.log('验证响应:', data);\n      if (data.success && data.data && data.data.user) {\n        console.log('Token验证成功，用户信息:', data.data.user);\n\n        // 更新验证时间和用户信息\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(data.data.user));\n        return {\n          success: true,\n          user: data.data.user\n        };\n      } else {\n        console.log('Token验证失败，服务器返回:', data);\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n        return {\n          success: false\n        };\n      }\n    } catch (error) {\n      var _error$response6, _error$response7;\n      console.error('令牌验证失败:', error);\n      console.error('错误状态码:', (_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : _error$response6.status);\n      console.error('错误详情:', (_error$response7 = error.response) === null || _error$response7 === void 0 ? void 0 : _error$response7.data);\n\n      // 检查是否为网络错误\n      const isNetworkError = !error.response;\n      if (isNetworkError) {\n        console.warn('验证token: 网络错误，检查本地用户信息');\n\n        // 网络错误时，如果有本地用户信息，尝试使用本地信息\n        const storedUserInfo = localStorage.getItem(USER_INFO_KEY);\n        if (storedUserInfo && tokenManager.isAuthenticated()) {\n          try {\n            const user = JSON.parse(storedUserInfo);\n            console.log('网络错误，使用本地用户信息:', user);\n            return {\n              success: true,\n              user: user,\n              networkError: true\n            };\n          } catch (e) {\n            console.error('解析本地用户信息失败:', e);\n          }\n        }\n        return {\n          success: false,\n          networkError: true\n        };\n      }\n\n      // 清除无效的token（除非是网络错误）\n      if (!isNetworkError) {\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      }\n      return {\n        success: false\n      };\n    }\n  }\n\n  /**\n   * 获取用户资料\n   */\n  async getProfile() {\n    try {\n      const token = tokenManager.getToken();\n      if (!token) {\n        return {\n          success: false\n        };\n      }\n\n      // 使用重试机制发送请求\n      const response = await retryAuthRequest({\n        method: 'get',\n        url: `${AUTH_API_URL}/profile`,\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n\n      // 请求拦截器会自动添加Authorization头\n      const data = response.data;\n      if (data.success && data.data && data.data.user) {\n        // 更新用户信息和验证时间\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(data.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        return {\n          success: true,\n          user: data.data.user\n        };\n      } else {\n        return {\n          success: false\n        };\n      }\n    } catch (error) {\n      var _error$response8;\n      console.error('获取用户资料失败:', error);\n\n      // 检查是否为网络错误\n      const isNetworkError = !error.response;\n      if (isNetworkError) {\n        return {\n          success: false,\n          networkError: true\n        };\n      }\n\n      // 如果是401错误，清除认证状态\n      if (((_error$response8 = error.response) === null || _error$response8 === void 0 ? void 0 : _error$response8.status) === 401) {\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      }\n      return {\n        success: false\n      };\n    }\n  }\n\n  /**\n   * 用户登出\n   */\n  async logout() {\n    try {\n      const token = tokenManager.getToken();\n      if (token) {\n        try {\n          // 可选：调用后端登出接口\n          await authApi.post('/logout');\n          // 注意：由于添加了请求拦截器，这里不需要手动添加Authorization头\n          console.log('成功调用登出API');\n        } catch (error) {\n          console.warn('登出API调用失败，但会继续清除本地状态:', error);\n        }\n      }\n\n      // 无论如何都要清除本地令牌和用户信息\n      tokenManager.removeToken();\n      localStorage.removeItem(USER_INFO_KEY);\n      localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      return {\n        success: true,\n        message: '已安全退出登录'\n      };\n    } catch (error) {\n      console.error('登出过程出错:', error);\n\n      // 即使出错，也要尝试清除本地状态\n      try {\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      } catch (e) {\n        console.error('清除本地状态失败:', e);\n      }\n      return {\n        success: false,\n        message: '登出过程出错，但已清除本地登录状态'\n      };\n    }\n  }\n\n  /**\n   * 检查是否已认证\n   */\n  isAuthenticated() {\n    return tokenManager.isAuthenticated();\n  }\n\n  /**\n   * 检查认证状态（本地检查，不发送网络请求）\n   */\n  checkAuthStatus() {\n    const isAuthenticated = this.isAuthenticated();\n    let user = null;\n\n    // 如果有token，尝试从localStorage获取用户信息\n    if (isAuthenticated) {\n      try {\n        const userInfo = localStorage.getItem(USER_INFO_KEY);\n        if (userInfo) {\n          user = JSON.parse(userInfo);\n        }\n      } catch (e) {\n        console.error('解析用户信息失败:', e);\n      }\n    }\n    return {\n      isAuthenticated,\n      user\n    };\n  }\n}\nexport const authService = new AuthService();","map":{"version":3,"names":["axios","message","tokenManager","AUTH_API_URL","_process$env$REACT_AP","process","env","REACT_APP_API_BASE_URL","replace","USER_INFO_KEY","AUTH_LAST_VERIFIED_KEY","REQUEST_TIMEOUT","MAX_RETRY_COUNT","RETRY_DELAY","authApi","create","baseURL","timeout","headers","retryAuthRequest","config","retryCount","error","isNetworkError","response","isServerError","status","console","log","Promise","resolve","setTimeout","interceptors","request","use","token","getToken","Authorization","Date","toISOString","NODE_ENV","_config$method","method","toUpperCase","url","data","params","reject","_response$config$meth","_config$method2","warn","removeToken","localStorage","removeItem","currentPath","window","location","pathname","sessionStorage","setItem","href","AuthService","register","userData","success","setToken","JSON","stringify","user","now","toString","_error$response","_error$response2","_error$response2$data","errorMessage","networkError","login","credentials","redirectPath","getItem","_error$response3","_error$response4","_error$response5","_error$response5$data","verifyToken","substring","split","length","isAuthenticated","storedUserInfo","localUser","parse","e","_error$response6","_error$response7","getProfile","_error$response8","logout","post","checkAuthStatus","userInfo","authService"],"sources":["E:/AICode/StockInsight/frontend/src/services/authService.ts"],"sourcesContent":["/**\n * 认证服务\n * 处理用户登录、注册、令牌管理等功能\n * 增强的错误处理和重试机制\n */\n\nimport axios, { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';\nimport { message } from 'antd';\nimport { tokenManager } from './api';\n\n// 认证API基础URL\n// const AUTH_API_URL = 'http://localhost:5000/api/auth';\n \n// 将硬编码URL改为使用环境变量\nconst AUTH_API_URL = process.env.REACT_APP_API_BASE_URL?.replace('/api', '/api/auth') || 'http://localhost:5000/api/auth';\n\n\n// 本地存储键\nconst USER_INFO_KEY = 'userInfo';\nconst AUTH_LAST_VERIFIED_KEY = 'auth_last_verified';\n\n// 配置常量\nconst REQUEST_TIMEOUT = 15000; // 请求超时时间（毫秒）\nconst MAX_RETRY_COUNT = 2; // 最大重试次数\nconst RETRY_DELAY = 1000; // 重试延迟（毫秒）\n\n// 创建认证专用的 axios 实例\nconst authApi = axios.create({\n  baseURL: AUTH_API_URL,\n  timeout: REQUEST_TIMEOUT,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\n// 请求重试函数\nconst retryAuthRequest = async (config: AxiosRequestConfig, retryCount: number = 0): Promise<AxiosResponse> => {\n  try {\n    return await axios(config);\n  } catch (error: any) {\n    // 只有在网络错误或5xx服务器错误时重试\n    const isNetworkError = !error.response;\n    const isServerError = error.response && error.response.status >= 500;\n    \n    if ((isNetworkError || isServerError) && retryCount < MAX_RETRY_COUNT) {\n      console.log(`认证请求失败，${RETRY_DELAY/1000}秒后重试 (${retryCount + 1}/${MAX_RETRY_COUNT})`);\n      await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));\n      return retryAuthRequest(config, retryCount + 1);\n    }\n    \n    throw error;\n  }\n};\n\n// 添加请求拦截器 - 自动添加token到请求头\nauthApi.interceptors.request.use(\n  (config) => {\n    const token = tokenManager.getToken();\n    if (token) {\n      config.headers = config.headers || {};\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n    \n    // 添加请求时间戳，用于调试\n    config.headers = config.headers || {};\n    config.headers['X-Request-Time'] = new Date().toISOString();\n    \n    // 记录请求信息（调试模式）\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`🔐 认证请求: ${config.method?.toUpperCase()} ${config.url}`, {\n        headers: { ...config.headers, Authorization: token ? '已设置' : '未设置' },\n        data: config.data,\n        params: config.params\n      });\n    }\n    \n    return config;\n  },\n  (error) => {\n    console.error('认证请求拦截器错误:', error);\n    return Promise.reject(error);\n  }\n);\n\n// 添加响应拦截器 - 处理token过期\nauthApi.interceptors.response.use(\n  (response) => {\n    // 记录响应信息（调试模式）\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`✅ 认证响应成功: ${response.config.method?.toUpperCase()} ${response.config.url}`, {\n        status: response.status,\n        data: response.data\n      });\n    }\n    \n    return response;\n  },\n  (error: AxiosError) => {\n    // 获取请求配置和响应\n    const { config, response } = error;\n    \n    // 记录错误信息（调试模式）\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`❌ 认证请求失败: ${config?.method?.toUpperCase()} ${config?.url}`, {\n        status: response?.status,\n        data: response?.data,\n        error: error.message\n      });\n    }\n    \n    // 处理401错误（未授权，通常是token过期或无效）\n    if (response?.status === 401) {\n      console.warn('认证请求收到401未授权响应');\n      \n      // 清除认证相关数据\n      tokenManager.removeToken();\n      localStorage.removeItem(USER_INFO_KEY);\n      localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      \n      // 如果不是验证接口的请求，显示提示并重定向\n      if (config?.url !== '/verify') {\n        message.error('登录已过期，请重新登录');\n        \n        // 使用延迟重定向，确保消息能够显示\n        setTimeout(() => {\n          // 保存当前URL，以便登录后返回\n          const currentPath = window.location.pathname;\n          if (currentPath !== '/login') {\n            sessionStorage.setItem('redirectAfterLogin', currentPath);\n          }\n          \n          window.location.href = '/login';\n        }, 1500);\n      }\n    }\n    \n    return Promise.reject(error);\n  }\n);\n\n// 用户数据类型\nexport interface User {\n  id: number;\n  username: string;\n  email: string;\n  created_at: string;\n  last_login?: string;\n}\n\n// 登录请求数据\nexport interface LoginRequest {\n  username: string;\n  password: string;\n}\n\n// 注册请求数据\nexport interface RegisterRequest {\n  username: string;\n  email: string;\n  password: string;\n}\n\n// 认证响应数据\nexport interface AuthResponse {\n  user: User;\n  token: string; // 后端返回的是token字段，而不是access_token\n}\n\n// API 响应格式\nexport interface ApiResponse<T> {\n  success: boolean;\n  data?: T;\n  message?: string;\n  error?: string;\n  networkError?: boolean;\n}\n\n// 认证服务类\nexport class AuthService {\n\n  /**\n   * 用户注册\n   */\n  async register(userData: RegisterRequest): Promise<ApiResponse<AuthResponse>> {\n    try {\n      // 使用重试机制发送请求\n      const response = await retryAuthRequest({\n        method: 'post',\n        url: `${AUTH_API_URL}/register`,\n        data: userData,\n        headers: { 'Content-Type': 'application/json' }\n      });\n      \n      const data = response.data;\n\n      if (data.success && data.data) {\n        // 保存令牌 - 后端返回的是token字段\n        tokenManager.setToken(data.data.token);\n        \n        // 保存用户信息和验证时间\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(data.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        \n        message.success('注册成功！');\n        return data;\n      } else {\n        message.error(data.message || '注册失败');\n        return data;\n      }\n    } catch (error: any) {\n      console.error('注册失败:', error.response?.data || error.message);\n      \n      // 检查是否为网络错误\n      const isNetworkError = !error.response;\n      if (isNetworkError) {\n        const errorMessage = '网络连接错误，请检查网络连接';\n        message.error(errorMessage);\n        return {\n          success: false,\n          message: errorMessage,\n          networkError: true\n        };\n      }\n      \n      const errorMessage = error.response?.data?.message || '注册失败，请重试';\n      message.error(errorMessage);\n      return {\n        success: false,\n        message: errorMessage,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * 用户登录\n   */\n  async login(credentials: LoginRequest): Promise<ApiResponse<AuthResponse>> {\n    try {\n      console.log('开始登录请求:', credentials);\n      console.log('API URL:', AUTH_API_URL);\n      \n      // 使用重试机制发送请求\n      const response = await retryAuthRequest({\n        method: 'post',\n        url: `${AUTH_API_URL}/login`,\n        data: credentials,\n        headers: { 'Content-Type': 'application/json' }\n      });\n      \n      console.log('登录响应:', response.data);\n      \n      const data = response.data;\n\n      if (data.success && data.data) {\n        // 保存令牌到localStorage - 后端返回的是token字段\n        tokenManager.setToken(data.data.token);\n        \n        // 保存用户信息和验证时间\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(data.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        \n        // 检查是否有登录后重定向路径\n        const redirectPath = sessionStorage.getItem('redirectAfterLogin');\n        if (redirectPath) {\n          console.log(`登录成功，将重定向到: ${redirectPath}`);\n          sessionStorage.removeItem('redirectAfterLogin');\n        }\n        \n        message.success('登录成功！');\n        return data;\n      } else {\n        console.error('登录失败:', data.message);\n        message.error(data.message || '登录失败');\n        return data;\n      }\n    } catch (error: any) {\n      console.error('登录请求异常:', error);\n      console.error('错误响应:', error.response?.data);\n      \n      // 检查是否为网络错误\n      const isNetworkError = !error.response;\n      if (isNetworkError) {\n        const errorMessage = '网络连接错误，请检查网络连接';\n        message.error(errorMessage);\n        return {\n          success: false,\n          message: errorMessage,\n          networkError: true\n        };\n      }\n      \n      // 处理特定错误\n      if (error.response?.status === 401) {\n        const errorMessage = '用户名或密码错误';\n        message.error(errorMessage);\n        return {\n          success: false,\n          message: errorMessage,\n          error: error.message\n        };\n      }\n      \n      const errorMessage = error.response?.data?.message || '登录失败，请重试';\n      message.error(errorMessage);\n      return {\n        success: false,\n        message: errorMessage,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * 验证令牌\n   */\n  async verifyToken(): Promise<{ success: boolean; user?: User; networkError?: boolean }> {\n    try {\n      const token = tokenManager.getToken();\n      if (!token) {\n        console.log('没有找到token，无法验证');\n        return { success: false };\n      }\n\n      console.log('开始验证token...', token.substring(0, 15) + '...');\n      console.log('Token格式检查:', token.split('.').length === 3 ? '有效' : '无效');\n      \n      // 直接检查token是否有效\n      if (!tokenManager.isAuthenticated()) {\n        console.warn('本地token验证失败，可能已过期');\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n        return { success: false };\n      }\n      \n      // 检查是否有本地存储的用户信息\n      const storedUserInfo = localStorage.getItem(USER_INFO_KEY);\n      let localUser: User | null = null;\n      \n      if (storedUserInfo) {\n        try {\n          localUser = JSON.parse(storedUserInfo);\n          console.log('从本地存储恢复用户信息:', localUser);\n        } catch (e) {\n          console.error('解析本地用户信息失败:', e);\n        }\n      }\n      \n      // 使用重试机制发送请求\n      console.log(`发送验证请求到: ${AUTH_API_URL}/verify`);\n      const response = await retryAuthRequest({\n        method: 'get',\n        url: `${AUTH_API_URL}/verify`,\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        },\n        timeout: 5000 // 降低超时时间，加快验证速度\n      });\n      \n      // 请求拦截器会自动添加Authorization头\n      const data = response.data;\n      console.log('验证响应:', data);\n      \n      if (data.success && data.data && data.data.user) {\n        console.log('Token验证成功，用户信息:', data.data.user);\n        \n        // 更新验证时间和用户信息\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(data.data.user));\n        \n        return { success: true, user: data.data.user };\n      } else {\n        console.log('Token验证失败，服务器返回:', data);\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n        return { success: false };\n      }\n    } catch (error: any) {\n      console.error('令牌验证失败:', error);\n      console.error('错误状态码:', error.response?.status);\n      console.error('错误详情:', error.response?.data);\n      \n      // 检查是否为网络错误\n      const isNetworkError = !error.response;\n      if (isNetworkError) {\n        console.warn('验证token: 网络错误，检查本地用户信息');\n        \n        // 网络错误时，如果有本地用户信息，尝试使用本地信息\n        const storedUserInfo = localStorage.getItem(USER_INFO_KEY);\n        if (storedUserInfo && tokenManager.isAuthenticated()) {\n          try {\n            const user = JSON.parse(storedUserInfo);\n            console.log('网络错误，使用本地用户信息:', user);\n            return {\n              success: true,\n              user: user,\n              networkError: true\n            };\n          } catch (e) {\n            console.error('解析本地用户信息失败:', e);\n          }\n        }\n        \n        return {\n          success: false,\n          networkError: true\n        };\n      }\n      \n      // 清除无效的token（除非是网络错误）\n      if (!isNetworkError) {\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      }\n      \n      return { success: false };\n    }\n  }\n\n  /**\n   * 获取用户资料\n   */\n  async getProfile(): Promise<{ success: boolean; user?: User; networkError?: boolean }> {\n    try {\n      const token = tokenManager.getToken();\n      if (!token) {\n        return { success: false };\n      }\n\n      // 使用重试机制发送请求\n      const response = await retryAuthRequest({\n        method: 'get',\n        url: `${AUTH_API_URL}/profile`,\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n      \n      // 请求拦截器会自动添加Authorization头\n      const data = response.data;\n      \n      if (data.success && data.data && data.data.user) {\n        // 更新用户信息和验证时间\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(data.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        \n        return { success: true, user: data.data.user };\n      } else {\n        return { success: false };\n      }\n    } catch (error: any) {\n      console.error('获取用户资料失败:', error);\n      \n      // 检查是否为网络错误\n      const isNetworkError = !error.response;\n      if (isNetworkError) {\n        return {\n          success: false,\n          networkError: true\n        };\n      }\n      \n      // 如果是401错误，清除认证状态\n      if (error.response?.status === 401) {\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      }\n      \n      return { success: false };\n    }\n  }\n\n  /**\n   * 用户登出\n   */\n  async logout(): Promise<{ success: boolean; message?: string }> {\n    try {\n      const token = tokenManager.getToken();\n      if (token) {\n        try {\n          // 可选：调用后端登出接口\n          await authApi.post('/logout');\n          // 注意：由于添加了请求拦截器，这里不需要手动添加Authorization头\n          console.log('成功调用登出API');\n        } catch (error) {\n          console.warn('登出API调用失败，但会继续清除本地状态:', error);\n        }\n      }\n      \n      // 无论如何都要清除本地令牌和用户信息\n      tokenManager.removeToken();\n      localStorage.removeItem(USER_INFO_KEY);\n      localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      \n      return { success: true, message: '已安全退出登录' };\n    } catch (error: any) {\n      console.error('登出过程出错:', error);\n      \n      // 即使出错，也要尝试清除本地状态\n      try {\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      } catch (e) {\n        console.error('清除本地状态失败:', e);\n      }\n      \n      return {\n        success: false,\n        message: '登出过程出错，但已清除本地登录状态'\n      };\n    }\n  }\n\n  /**\n   * 检查是否已认证\n   */\n  isAuthenticated(): boolean {\n    return tokenManager.isAuthenticated();\n  }\n  \n  /**\n   * 检查认证状态（本地检查，不发送网络请求）\n   */\n  checkAuthStatus(): { isAuthenticated: boolean; user: User | null } {\n    const isAuthenticated = this.isAuthenticated();\n    let user: User | null = null;\n    \n    // 如果有token，尝试从localStorage获取用户信息\n    if (isAuthenticated) {\n      try {\n        const userInfo = localStorage.getItem(USER_INFO_KEY);\n        if (userInfo) {\n          user = JSON.parse(userInfo);\n        }\n      } catch (e) {\n        console.error('解析用户信息失败:', e);\n      }\n    }\n    \n    return { isAuthenticated, user };\n  }\n}\n\nexport const authService = new AuthService();"],"mappings":";AAAA;AACA;AACA;AACA;AACA;;AAEA,OAAOA,KAAK,MAAyD,OAAO;AAC5E,SAASC,OAAO,QAAQ,MAAM;AAC9B,SAASC,YAAY,QAAQ,OAAO;;AAEpC;AACA;;AAEA;AACA,MAAMC,YAAY,GAAG,EAAAC,qBAAA,GAAAC,OAAO,CAACC,GAAG,CAACC,sBAAsB,cAAAH,qBAAA,uBAAlCA,qBAAA,CAAoCI,OAAO,CAAC,MAAM,EAAE,WAAW,CAAC,KAAI,gCAAgC;;AAGzH;AACA,MAAMC,aAAa,GAAG,UAAU;AAChC,MAAMC,sBAAsB,GAAG,oBAAoB;;AAEnD;AACA,MAAMC,eAAe,GAAG,KAAK,CAAC,CAAC;AAC/B,MAAMC,eAAe,GAAG,CAAC,CAAC,CAAC;AAC3B,MAAMC,WAAW,GAAG,IAAI,CAAC,CAAC;;AAE1B;AACA,MAAMC,OAAO,GAAGd,KAAK,CAACe,MAAM,CAAC;EAC3BC,OAAO,EAAEb,YAAY;EACrBc,OAAO,EAAEN,eAAe;EACxBO,OAAO,EAAE;IACP,cAAc,EAAE;EAClB;AACF,CAAC,CAAC;;AAEF;AACA,MAAMC,gBAAgB,GAAG,MAAAA,CAAOC,MAA0B,EAAEC,UAAkB,GAAG,CAAC,KAA6B;EAC7G,IAAI;IACF,OAAO,MAAMrB,KAAK,CAACoB,MAAM,CAAC;EAC5B,CAAC,CAAC,OAAOE,KAAU,EAAE;IACnB;IACA,MAAMC,cAAc,GAAG,CAACD,KAAK,CAACE,QAAQ;IACtC,MAAMC,aAAa,GAAGH,KAAK,CAACE,QAAQ,IAAIF,KAAK,CAACE,QAAQ,CAACE,MAAM,IAAI,GAAG;IAEpE,IAAI,CAACH,cAAc,IAAIE,aAAa,KAAKJ,UAAU,GAAGT,eAAe,EAAE;MACrEe,OAAO,CAACC,GAAG,CAAC,UAAUf,WAAW,GAAC,IAAI,SAASQ,UAAU,GAAG,CAAC,IAAIT,eAAe,GAAG,CAAC;MACpF,MAAM,IAAIiB,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAEjB,WAAW,CAAC,CAAC;MAC9D,OAAOM,gBAAgB,CAACC,MAAM,EAAEC,UAAU,GAAG,CAAC,CAAC;IACjD;IAEA,MAAMC,KAAK;EACb;AACF,CAAC;;AAED;AACAR,OAAO,CAACkB,YAAY,CAACC,OAAO,CAACC,GAAG,CAC7Bd,MAAM,IAAK;EACV,MAAMe,KAAK,GAAGjC,YAAY,CAACkC,QAAQ,CAAC,CAAC;EACrC,IAAID,KAAK,EAAE;IACTf,MAAM,CAACF,OAAO,GAAGE,MAAM,CAACF,OAAO,IAAI,CAAC,CAAC;IACrCE,MAAM,CAACF,OAAO,CAACmB,aAAa,GAAG,UAAUF,KAAK,EAAE;EAClD;;EAEA;EACAf,MAAM,CAACF,OAAO,GAAGE,MAAM,CAACF,OAAO,IAAI,CAAC,CAAC;EACrCE,MAAM,CAACF,OAAO,CAAC,gBAAgB,CAAC,GAAG,IAAIoB,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;;EAE3D;EACA,IAAIlC,OAAO,CAACC,GAAG,CAACkC,QAAQ,KAAK,aAAa,EAAE;IAAA,IAAAC,cAAA;IAC1Cd,OAAO,CAACC,GAAG,CAAC,aAAAa,cAAA,GAAYrB,MAAM,CAACsB,MAAM,cAAAD,cAAA,uBAAbA,cAAA,CAAeE,WAAW,CAAC,CAAC,IAAIvB,MAAM,CAACwB,GAAG,EAAE,EAAE;MACpE1B,OAAO,EAAE;QAAE,GAAGE,MAAM,CAACF,OAAO;QAAEmB,aAAa,EAAEF,KAAK,GAAG,KAAK,GAAG;MAAM,CAAC;MACpEU,IAAI,EAAEzB,MAAM,CAACyB,IAAI;MACjBC,MAAM,EAAE1B,MAAM,CAAC0B;IACjB,CAAC,CAAC;EACJ;EAEA,OAAO1B,MAAM;AACf,CAAC,EACAE,KAAK,IAAK;EACTK,OAAO,CAACL,KAAK,CAAC,YAAY,EAAEA,KAAK,CAAC;EAClC,OAAOO,OAAO,CAACkB,MAAM,CAACzB,KAAK,CAAC;AAC9B,CACF,CAAC;;AAED;AACAR,OAAO,CAACkB,YAAY,CAACR,QAAQ,CAACU,GAAG,CAC9BV,QAAQ,IAAK;EACZ;EACA,IAAInB,OAAO,CAACC,GAAG,CAACkC,QAAQ,KAAK,aAAa,EAAE;IAAA,IAAAQ,qBAAA;IAC1CrB,OAAO,CAACC,GAAG,CAAC,cAAAoB,qBAAA,GAAaxB,QAAQ,CAACJ,MAAM,CAACsB,MAAM,cAAAM,qBAAA,uBAAtBA,qBAAA,CAAwBL,WAAW,CAAC,CAAC,IAAInB,QAAQ,CAACJ,MAAM,CAACwB,GAAG,EAAE,EAAE;MACvFlB,MAAM,EAAEF,QAAQ,CAACE,MAAM;MACvBmB,IAAI,EAAErB,QAAQ,CAACqB;IACjB,CAAC,CAAC;EACJ;EAEA,OAAOrB,QAAQ;AACjB,CAAC,EACAF,KAAiB,IAAK;EACrB;EACA,MAAM;IAAEF,MAAM;IAAEI;EAAS,CAAC,GAAGF,KAAK;;EAElC;EACA,IAAIjB,OAAO,CAACC,GAAG,CAACkC,QAAQ,KAAK,aAAa,EAAE;IAAA,IAAAS,eAAA;IAC1CtB,OAAO,CAACL,KAAK,CAAC,aAAaF,MAAM,aAANA,MAAM,wBAAA6B,eAAA,GAAN7B,MAAM,CAAEsB,MAAM,cAAAO,eAAA,uBAAdA,eAAA,CAAgBN,WAAW,CAAC,CAAC,IAAIvB,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEwB,GAAG,EAAE,EAAE;MACzElB,MAAM,EAAEF,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEE,MAAM;MACxBmB,IAAI,EAAErB,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEqB,IAAI;MACpBvB,KAAK,EAAEA,KAAK,CAACrB;IACf,CAAC,CAAC;EACJ;;EAEA;EACA,IAAI,CAAAuB,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEE,MAAM,MAAK,GAAG,EAAE;IAC5BC,OAAO,CAACuB,IAAI,CAAC,gBAAgB,CAAC;;IAE9B;IACAhD,YAAY,CAACiD,WAAW,CAAC,CAAC;IAC1BC,YAAY,CAACC,UAAU,CAAC5C,aAAa,CAAC;IACtC2C,YAAY,CAACC,UAAU,CAAC3C,sBAAsB,CAAC;;IAE/C;IACA,IAAI,CAAAU,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEwB,GAAG,MAAK,SAAS,EAAE;MAC7B3C,OAAO,CAACqB,KAAK,CAAC,aAAa,CAAC;;MAE5B;MACAS,UAAU,CAAC,MAAM;QACf;QACA,MAAMuB,WAAW,GAAGC,MAAM,CAACC,QAAQ,CAACC,QAAQ;QAC5C,IAAIH,WAAW,KAAK,QAAQ,EAAE;UAC5BI,cAAc,CAACC,OAAO,CAAC,oBAAoB,EAAEL,WAAW,CAAC;QAC3D;QAEAC,MAAM,CAACC,QAAQ,CAACI,IAAI,GAAG,QAAQ;MACjC,CAAC,EAAE,IAAI,CAAC;IACV;EACF;EAEA,OAAO/B,OAAO,CAACkB,MAAM,CAACzB,KAAK,CAAC;AAC9B,CACF,CAAC;;AAED;;AASA;;AAMA;;AAOA;;AAMA;;AASA;AACA,OAAO,MAAMuC,WAAW,CAAC;EAEvB;AACF;AACA;EACE,MAAMC,QAAQA,CAACC,QAAyB,EAAsC;IAC5E,IAAI;MACF;MACA,MAAMvC,QAAQ,GAAG,MAAML,gBAAgB,CAAC;QACtCuB,MAAM,EAAE,MAAM;QACdE,GAAG,EAAE,GAAGzC,YAAY,WAAW;QAC/B0C,IAAI,EAAEkB,QAAQ;QACd7C,OAAO,EAAE;UAAE,cAAc,EAAE;QAAmB;MAChD,CAAC,CAAC;MAEF,MAAM2B,IAAI,GAAGrB,QAAQ,CAACqB,IAAI;MAE1B,IAAIA,IAAI,CAACmB,OAAO,IAAInB,IAAI,CAACA,IAAI,EAAE;QAC7B;QACA3C,YAAY,CAAC+D,QAAQ,CAACpB,IAAI,CAACA,IAAI,CAACV,KAAK,CAAC;;QAEtC;QACAiB,YAAY,CAACO,OAAO,CAAClD,aAAa,EAAEyD,IAAI,CAACC,SAAS,CAACtB,IAAI,CAACA,IAAI,CAACuB,IAAI,CAAC,CAAC;QACnEhB,YAAY,CAACO,OAAO,CAACjD,sBAAsB,EAAE4B,IAAI,CAAC+B,GAAG,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,CAAC;QAEnErE,OAAO,CAAC+D,OAAO,CAAC,OAAO,CAAC;QACxB,OAAOnB,IAAI;MACb,CAAC,MAAM;QACL5C,OAAO,CAACqB,KAAK,CAACuB,IAAI,CAAC5C,OAAO,IAAI,MAAM,CAAC;QACrC,OAAO4C,IAAI;MACb;IACF,CAAC,CAAC,OAAOvB,KAAU,EAAE;MAAA,IAAAiD,eAAA,EAAAC,gBAAA,EAAAC,qBAAA;MACnB9C,OAAO,CAACL,KAAK,CAAC,OAAO,EAAE,EAAAiD,eAAA,GAAAjD,KAAK,CAACE,QAAQ,cAAA+C,eAAA,uBAAdA,eAAA,CAAgB1B,IAAI,KAAIvB,KAAK,CAACrB,OAAO,CAAC;;MAE7D;MACA,MAAMsB,cAAc,GAAG,CAACD,KAAK,CAACE,QAAQ;MACtC,IAAID,cAAc,EAAE;QAClB,MAAMmD,YAAY,GAAG,gBAAgB;QACrCzE,OAAO,CAACqB,KAAK,CAACoD,YAAY,CAAC;QAC3B,OAAO;UACLV,OAAO,EAAE,KAAK;UACd/D,OAAO,EAAEyE,YAAY;UACrBC,YAAY,EAAE;QAChB,CAAC;MACH;MAEA,MAAMD,YAAY,GAAG,EAAAF,gBAAA,GAAAlD,KAAK,CAACE,QAAQ,cAAAgD,gBAAA,wBAAAC,qBAAA,GAAdD,gBAAA,CAAgB3B,IAAI,cAAA4B,qBAAA,uBAApBA,qBAAA,CAAsBxE,OAAO,KAAI,UAAU;MAChEA,OAAO,CAACqB,KAAK,CAACoD,YAAY,CAAC;MAC3B,OAAO;QACLV,OAAO,EAAE,KAAK;QACd/D,OAAO,EAAEyE,YAAY;QACrBpD,KAAK,EAAEA,KAAK,CAACrB;MACf,CAAC;IACH;EACF;;EAEA;AACF;AACA;EACE,MAAM2E,KAAKA,CAACC,WAAyB,EAAsC;IACzE,IAAI;MACFlD,OAAO,CAACC,GAAG,CAAC,SAAS,EAAEiD,WAAW,CAAC;MACnClD,OAAO,CAACC,GAAG,CAAC,UAAU,EAAEzB,YAAY,CAAC;;MAErC;MACA,MAAMqB,QAAQ,GAAG,MAAML,gBAAgB,CAAC;QACtCuB,MAAM,EAAE,MAAM;QACdE,GAAG,EAAE,GAAGzC,YAAY,QAAQ;QAC5B0C,IAAI,EAAEgC,WAAW;QACjB3D,OAAO,EAAE;UAAE,cAAc,EAAE;QAAmB;MAChD,CAAC,CAAC;MAEFS,OAAO,CAACC,GAAG,CAAC,OAAO,EAAEJ,QAAQ,CAACqB,IAAI,CAAC;MAEnC,MAAMA,IAAI,GAAGrB,QAAQ,CAACqB,IAAI;MAE1B,IAAIA,IAAI,CAACmB,OAAO,IAAInB,IAAI,CAACA,IAAI,EAAE;QAC7B;QACA3C,YAAY,CAAC+D,QAAQ,CAACpB,IAAI,CAACA,IAAI,CAACV,KAAK,CAAC;;QAEtC;QACAiB,YAAY,CAACO,OAAO,CAAClD,aAAa,EAAEyD,IAAI,CAACC,SAAS,CAACtB,IAAI,CAACA,IAAI,CAACuB,IAAI,CAAC,CAAC;QACnEhB,YAAY,CAACO,OAAO,CAACjD,sBAAsB,EAAE4B,IAAI,CAAC+B,GAAG,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,CAAC;;QAEnE;QACA,MAAMQ,YAAY,GAAGpB,cAAc,CAACqB,OAAO,CAAC,oBAAoB,CAAC;QACjE,IAAID,YAAY,EAAE;UAChBnD,OAAO,CAACC,GAAG,CAAC,eAAekD,YAAY,EAAE,CAAC;UAC1CpB,cAAc,CAACL,UAAU,CAAC,oBAAoB,CAAC;QACjD;QAEApD,OAAO,CAAC+D,OAAO,CAAC,OAAO,CAAC;QACxB,OAAOnB,IAAI;MACb,CAAC,MAAM;QACLlB,OAAO,CAACL,KAAK,CAAC,OAAO,EAAEuB,IAAI,CAAC5C,OAAO,CAAC;QACpCA,OAAO,CAACqB,KAAK,CAACuB,IAAI,CAAC5C,OAAO,IAAI,MAAM,CAAC;QACrC,OAAO4C,IAAI;MACb;IACF,CAAC,CAAC,OAAOvB,KAAU,EAAE;MAAA,IAAA0D,gBAAA,EAAAC,gBAAA,EAAAC,gBAAA,EAAAC,qBAAA;MACnBxD,OAAO,CAACL,KAAK,CAAC,SAAS,EAAEA,KAAK,CAAC;MAC/BK,OAAO,CAACL,KAAK,CAAC,OAAO,GAAA0D,gBAAA,GAAE1D,KAAK,CAACE,QAAQ,cAAAwD,gBAAA,uBAAdA,gBAAA,CAAgBnC,IAAI,CAAC;;MAE5C;MACA,MAAMtB,cAAc,GAAG,CAACD,KAAK,CAACE,QAAQ;MACtC,IAAID,cAAc,EAAE;QAClB,MAAMmD,YAAY,GAAG,gBAAgB;QACrCzE,OAAO,CAACqB,KAAK,CAACoD,YAAY,CAAC;QAC3B,OAAO;UACLV,OAAO,EAAE,KAAK;UACd/D,OAAO,EAAEyE,YAAY;UACrBC,YAAY,EAAE;QAChB,CAAC;MACH;;MAEA;MACA,IAAI,EAAAM,gBAAA,GAAA3D,KAAK,CAACE,QAAQ,cAAAyD,gBAAA,uBAAdA,gBAAA,CAAgBvD,MAAM,MAAK,GAAG,EAAE;QAClC,MAAMgD,YAAY,GAAG,UAAU;QAC/BzE,OAAO,CAACqB,KAAK,CAACoD,YAAY,CAAC;QAC3B,OAAO;UACLV,OAAO,EAAE,KAAK;UACd/D,OAAO,EAAEyE,YAAY;UACrBpD,KAAK,EAAEA,KAAK,CAACrB;QACf,CAAC;MACH;MAEA,MAAMyE,YAAY,GAAG,EAAAQ,gBAAA,GAAA5D,KAAK,CAACE,QAAQ,cAAA0D,gBAAA,wBAAAC,qBAAA,GAAdD,gBAAA,CAAgBrC,IAAI,cAAAsC,qBAAA,uBAApBA,qBAAA,CAAsBlF,OAAO,KAAI,UAAU;MAChEA,OAAO,CAACqB,KAAK,CAACoD,YAAY,CAAC;MAC3B,OAAO;QACLV,OAAO,EAAE,KAAK;QACd/D,OAAO,EAAEyE,YAAY;QACrBpD,KAAK,EAAEA,KAAK,CAACrB;MACf,CAAC;IACH;EACF;;EAEA;AACF;AACA;EACE,MAAMmF,WAAWA,CAAA,EAAuE;IACtF,IAAI;MACF,MAAMjD,KAAK,GAAGjC,YAAY,CAACkC,QAAQ,CAAC,CAAC;MACrC,IAAI,CAACD,KAAK,EAAE;QACVR,OAAO,CAACC,GAAG,CAAC,gBAAgB,CAAC;QAC7B,OAAO;UAAEoC,OAAO,EAAE;QAAM,CAAC;MAC3B;MAEArC,OAAO,CAACC,GAAG,CAAC,cAAc,EAAEO,KAAK,CAACkD,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,KAAK,CAAC;MAC3D1D,OAAO,CAACC,GAAG,CAAC,YAAY,EAAEO,KAAK,CAACmD,KAAK,CAAC,GAAG,CAAC,CAACC,MAAM,KAAK,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC;;MAEtE;MACA,IAAI,CAACrF,YAAY,CAACsF,eAAe,CAAC,CAAC,EAAE;QACnC7D,OAAO,CAACuB,IAAI,CAAC,mBAAmB,CAAC;QACjChD,YAAY,CAACiD,WAAW,CAAC,CAAC;QAC1BC,YAAY,CAACC,UAAU,CAAC5C,aAAa,CAAC;QACtC2C,YAAY,CAACC,UAAU,CAAC3C,sBAAsB,CAAC;QAC/C,OAAO;UAAEsD,OAAO,EAAE;QAAM,CAAC;MAC3B;;MAEA;MACA,MAAMyB,cAAc,GAAGrC,YAAY,CAAC2B,OAAO,CAACtE,aAAa,CAAC;MAC1D,IAAIiF,SAAsB,GAAG,IAAI;MAEjC,IAAID,cAAc,EAAE;QAClB,IAAI;UACFC,SAAS,GAAGxB,IAAI,CAACyB,KAAK,CAACF,cAAc,CAAC;UACtC9D,OAAO,CAACC,GAAG,CAAC,cAAc,EAAE8D,SAAS,CAAC;QACxC,CAAC,CAAC,OAAOE,CAAC,EAAE;UACVjE,OAAO,CAACL,KAAK,CAAC,aAAa,EAAEsE,CAAC,CAAC;QACjC;MACF;;MAEA;MACAjE,OAAO,CAACC,GAAG,CAAC,YAAYzB,YAAY,SAAS,CAAC;MAC9C,MAAMqB,QAAQ,GAAG,MAAML,gBAAgB,CAAC;QACtCuB,MAAM,EAAE,KAAK;QACbE,GAAG,EAAE,GAAGzC,YAAY,SAAS;QAC7Be,OAAO,EAAE;UACP,eAAe,EAAE,UAAUiB,KAAK,EAAE;UAClC,cAAc,EAAE;QAClB,CAAC;QACDlB,OAAO,EAAE,IAAI,CAAC;MAChB,CAAC,CAAC;;MAEF;MACA,MAAM4B,IAAI,GAAGrB,QAAQ,CAACqB,IAAI;MAC1BlB,OAAO,CAACC,GAAG,CAAC,OAAO,EAAEiB,IAAI,CAAC;MAE1B,IAAIA,IAAI,CAACmB,OAAO,IAAInB,IAAI,CAACA,IAAI,IAAIA,IAAI,CAACA,IAAI,CAACuB,IAAI,EAAE;QAC/CzC,OAAO,CAACC,GAAG,CAAC,iBAAiB,EAAEiB,IAAI,CAACA,IAAI,CAACuB,IAAI,CAAC;;QAE9C;QACAhB,YAAY,CAACO,OAAO,CAACjD,sBAAsB,EAAE4B,IAAI,CAAC+B,GAAG,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,CAAC;QACnElB,YAAY,CAACO,OAAO,CAAClD,aAAa,EAAEyD,IAAI,CAACC,SAAS,CAACtB,IAAI,CAACA,IAAI,CAACuB,IAAI,CAAC,CAAC;QAEnE,OAAO;UAAEJ,OAAO,EAAE,IAAI;UAAEI,IAAI,EAAEvB,IAAI,CAACA,IAAI,CAACuB;QAAK,CAAC;MAChD,CAAC,MAAM;QACLzC,OAAO,CAACC,GAAG,CAAC,kBAAkB,EAAEiB,IAAI,CAAC;QACrC3C,YAAY,CAACiD,WAAW,CAAC,CAAC;QAC1BC,YAAY,CAACC,UAAU,CAAC5C,aAAa,CAAC;QACtC2C,YAAY,CAACC,UAAU,CAAC3C,sBAAsB,CAAC;QAC/C,OAAO;UAAEsD,OAAO,EAAE;QAAM,CAAC;MAC3B;IACF,CAAC,CAAC,OAAO1C,KAAU,EAAE;MAAA,IAAAuE,gBAAA,EAAAC,gBAAA;MACnBnE,OAAO,CAACL,KAAK,CAAC,SAAS,EAAEA,KAAK,CAAC;MAC/BK,OAAO,CAACL,KAAK,CAAC,QAAQ,GAAAuE,gBAAA,GAAEvE,KAAK,CAACE,QAAQ,cAAAqE,gBAAA,uBAAdA,gBAAA,CAAgBnE,MAAM,CAAC;MAC/CC,OAAO,CAACL,KAAK,CAAC,OAAO,GAAAwE,gBAAA,GAAExE,KAAK,CAACE,QAAQ,cAAAsE,gBAAA,uBAAdA,gBAAA,CAAgBjD,IAAI,CAAC;;MAE5C;MACA,MAAMtB,cAAc,GAAG,CAACD,KAAK,CAACE,QAAQ;MACtC,IAAID,cAAc,EAAE;QAClBI,OAAO,CAACuB,IAAI,CAAC,wBAAwB,CAAC;;QAEtC;QACA,MAAMuC,cAAc,GAAGrC,YAAY,CAAC2B,OAAO,CAACtE,aAAa,CAAC;QAC1D,IAAIgF,cAAc,IAAIvF,YAAY,CAACsF,eAAe,CAAC,CAAC,EAAE;UACpD,IAAI;YACF,MAAMpB,IAAI,GAAGF,IAAI,CAACyB,KAAK,CAACF,cAAc,CAAC;YACvC9D,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAEwC,IAAI,CAAC;YACnC,OAAO;cACLJ,OAAO,EAAE,IAAI;cACbI,IAAI,EAAEA,IAAI;cACVO,YAAY,EAAE;YAChB,CAAC;UACH,CAAC,CAAC,OAAOiB,CAAC,EAAE;YACVjE,OAAO,CAACL,KAAK,CAAC,aAAa,EAAEsE,CAAC,CAAC;UACjC;QACF;QAEA,OAAO;UACL5B,OAAO,EAAE,KAAK;UACdW,YAAY,EAAE;QAChB,CAAC;MACH;;MAEA;MACA,IAAI,CAACpD,cAAc,EAAE;QACnBrB,YAAY,CAACiD,WAAW,CAAC,CAAC;QAC1BC,YAAY,CAACC,UAAU,CAAC5C,aAAa,CAAC;QACtC2C,YAAY,CAACC,UAAU,CAAC3C,sBAAsB,CAAC;MACjD;MAEA,OAAO;QAAEsD,OAAO,EAAE;MAAM,CAAC;IAC3B;EACF;;EAEA;AACF;AACA;EACE,MAAM+B,UAAUA,CAAA,EAAuE;IACrF,IAAI;MACF,MAAM5D,KAAK,GAAGjC,YAAY,CAACkC,QAAQ,CAAC,CAAC;MACrC,IAAI,CAACD,KAAK,EAAE;QACV,OAAO;UAAE6B,OAAO,EAAE;QAAM,CAAC;MAC3B;;MAEA;MACA,MAAMxC,QAAQ,GAAG,MAAML,gBAAgB,CAAC;QACtCuB,MAAM,EAAE,KAAK;QACbE,GAAG,EAAE,GAAGzC,YAAY,UAAU;QAC9Be,OAAO,EAAE;UACP,eAAe,EAAE,UAAUiB,KAAK,EAAE;UAClC,cAAc,EAAE;QAClB;MACF,CAAC,CAAC;;MAEF;MACA,MAAMU,IAAI,GAAGrB,QAAQ,CAACqB,IAAI;MAE1B,IAAIA,IAAI,CAACmB,OAAO,IAAInB,IAAI,CAACA,IAAI,IAAIA,IAAI,CAACA,IAAI,CAACuB,IAAI,EAAE;QAC/C;QACAhB,YAAY,CAACO,OAAO,CAAClD,aAAa,EAAEyD,IAAI,CAACC,SAAS,CAACtB,IAAI,CAACA,IAAI,CAACuB,IAAI,CAAC,CAAC;QACnEhB,YAAY,CAACO,OAAO,CAACjD,sBAAsB,EAAE4B,IAAI,CAAC+B,GAAG,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,CAAC;QAEnE,OAAO;UAAEN,OAAO,EAAE,IAAI;UAAEI,IAAI,EAAEvB,IAAI,CAACA,IAAI,CAACuB;QAAK,CAAC;MAChD,CAAC,MAAM;QACL,OAAO;UAAEJ,OAAO,EAAE;QAAM,CAAC;MAC3B;IACF,CAAC,CAAC,OAAO1C,KAAU,EAAE;MAAA,IAAA0E,gBAAA;MACnBrE,OAAO,CAACL,KAAK,CAAC,WAAW,EAAEA,KAAK,CAAC;;MAEjC;MACA,MAAMC,cAAc,GAAG,CAACD,KAAK,CAACE,QAAQ;MACtC,IAAID,cAAc,EAAE;QAClB,OAAO;UACLyC,OAAO,EAAE,KAAK;UACdW,YAAY,EAAE;QAChB,CAAC;MACH;;MAEA;MACA,IAAI,EAAAqB,gBAAA,GAAA1E,KAAK,CAACE,QAAQ,cAAAwE,gBAAA,uBAAdA,gBAAA,CAAgBtE,MAAM,MAAK,GAAG,EAAE;QAClCxB,YAAY,CAACiD,WAAW,CAAC,CAAC;QAC1BC,YAAY,CAACC,UAAU,CAAC5C,aAAa,CAAC;QACtC2C,YAAY,CAACC,UAAU,CAAC3C,sBAAsB,CAAC;MACjD;MAEA,OAAO;QAAEsD,OAAO,EAAE;MAAM,CAAC;IAC3B;EACF;;EAEA;AACF;AACA;EACE,MAAMiC,MAAMA,CAAA,EAAoD;IAC9D,IAAI;MACF,MAAM9D,KAAK,GAAGjC,YAAY,CAACkC,QAAQ,CAAC,CAAC;MACrC,IAAID,KAAK,EAAE;QACT,IAAI;UACF;UACA,MAAMrB,OAAO,CAACoF,IAAI,CAAC,SAAS,CAAC;UAC7B;UACAvE,OAAO,CAACC,GAAG,CAAC,WAAW,CAAC;QAC1B,CAAC,CAAC,OAAON,KAAK,EAAE;UACdK,OAAO,CAACuB,IAAI,CAAC,uBAAuB,EAAE5B,KAAK,CAAC;QAC9C;MACF;;MAEA;MACApB,YAAY,CAACiD,WAAW,CAAC,CAAC;MAC1BC,YAAY,CAACC,UAAU,CAAC5C,aAAa,CAAC;MACtC2C,YAAY,CAACC,UAAU,CAAC3C,sBAAsB,CAAC;MAE/C,OAAO;QAAEsD,OAAO,EAAE,IAAI;QAAE/D,OAAO,EAAE;MAAU,CAAC;IAC9C,CAAC,CAAC,OAAOqB,KAAU,EAAE;MACnBK,OAAO,CAACL,KAAK,CAAC,SAAS,EAAEA,KAAK,CAAC;;MAE/B;MACA,IAAI;QACFpB,YAAY,CAACiD,WAAW,CAAC,CAAC;QAC1BC,YAAY,CAACC,UAAU,CAAC5C,aAAa,CAAC;QACtC2C,YAAY,CAACC,UAAU,CAAC3C,sBAAsB,CAAC;MACjD,CAAC,CAAC,OAAOkF,CAAC,EAAE;QACVjE,OAAO,CAACL,KAAK,CAAC,WAAW,EAAEsE,CAAC,CAAC;MAC/B;MAEA,OAAO;QACL5B,OAAO,EAAE,KAAK;QACd/D,OAAO,EAAE;MACX,CAAC;IACH;EACF;;EAEA;AACF;AACA;EACEuF,eAAeA,CAAA,EAAY;IACzB,OAAOtF,YAAY,CAACsF,eAAe,CAAC,CAAC;EACvC;;EAEA;AACF;AACA;EACEW,eAAeA,CAAA,EAAoD;IACjE,MAAMX,eAAe,GAAG,IAAI,CAACA,eAAe,CAAC,CAAC;IAC9C,IAAIpB,IAAiB,GAAG,IAAI;;IAE5B;IACA,IAAIoB,eAAe,EAAE;MACnB,IAAI;QACF,MAAMY,QAAQ,GAAGhD,YAAY,CAAC2B,OAAO,CAACtE,aAAa,CAAC;QACpD,IAAI2F,QAAQ,EAAE;UACZhC,IAAI,GAAGF,IAAI,CAACyB,KAAK,CAACS,QAAQ,CAAC;QAC7B;MACF,CAAC,CAAC,OAAOR,CAAC,EAAE;QACVjE,OAAO,CAACL,KAAK,CAAC,WAAW,EAAEsE,CAAC,CAAC;MAC/B;IACF;IAEA,OAAO;MAAEJ,eAAe;MAAEpB;IAAK,CAAC;EAClC;AACF;AAEA,OAAO,MAAMiC,WAAW,GAAG,IAAIxC,WAAW,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}