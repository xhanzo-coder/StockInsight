{"ast":null,"code":"import { COMMENT, RULESET, DECLARATION } from './Enum.js';\nimport { abs, charat, trim, from, sizeof, strlen, substr, append, replace, indexof } from './Utility.js';\nimport { node, char, prev, next, peek, token, caret, alloc, dealloc, delimit, whitespace, escaping, identifier, commenter } from './Tokenizer.js';\n\n/**\r\n * @param {string} value\r\n * @return {object[]}\r\n */\nexport function compile(value) {\n  return dealloc(parse('', null, null, null, [''], value = alloc(value), 0, [0], value));\n}\n\n/**\r\n * @param {string} value\r\n * @param {object} root\r\n * @param {object?} parent\r\n * @param {string[]} rule\r\n * @param {string[]} rules\r\n * @param {string[]} rulesets\r\n * @param {number[]} pseudo\r\n * @param {number[]} points\r\n * @param {string[]} declarations\r\n * @return {object}\r\n */\nexport function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {\n  var index = 0;\n  var offset = 0;\n  var length = pseudo;\n  var atrule = 0;\n  var property = 0;\n  var previous = 0;\n  var variable = 1;\n  var scanning = 1;\n  var ampersand = 1;\n  var character = 0;\n  var type = '';\n  var props = rules;\n  var children = rulesets;\n  var reference = rule;\n  var characters = type;\n  while (scanning) switch (previous = character, character = next()) {\n    // (\n    case 40:\n      if (previous != 108 && charat(characters, length - 1) == 58) {\n        if (indexof(characters += replace(delimit(character), '&', '&\\f'), '&\\f', abs(index ? points[index - 1] : 0)) != -1) ampersand = -1;\n        break;\n      }\n    // \" ' [\n    case 34:\n    case 39:\n    case 91:\n      characters += delimit(character);\n      break;\n    // \\t \\n \\r \\s\n    case 9:\n    case 10:\n    case 13:\n    case 32:\n      characters += whitespace(previous);\n      break;\n    // \\\n    case 92:\n      characters += escaping(caret() - 1, 7);\n      continue;\n    // /\n    case 47:\n      switch (peek()) {\n        case 42:\n        case 47:\n          append(comment(commenter(next(), caret()), root, parent, declarations), declarations);\n          if ((token(previous || 1) == 5 || token(peek() || 1) == 5) && strlen(characters) && substr(characters, -1, void 0) !== ' ') characters += ' ';\n          break;\n        default:\n          characters += '/';\n      }\n      break;\n    // {\n    case 123 * variable:\n      points[index++] = strlen(characters) * ampersand;\n    // } ; \\0\n    case 125 * variable:\n    case 59:\n    case 0:\n      switch (character) {\n        // \\0 }\n        case 0:\n        case 125:\n          scanning = 0;\n        // ;\n        case 59 + offset:\n          if (ampersand == -1) characters = replace(characters, /\\f/g, '');\n          if (property > 0 && (strlen(characters) - length || variable === 0 && previous === 47)) append(property > 32 ? declaration(characters + ';', rule, parent, length - 1, declarations) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2, declarations), declarations);\n          break;\n        // @ ;\n        case 59:\n          characters += ';';\n        // { rule/at-rule\n        default:\n          append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length, rulesets), rulesets);\n          if (character === 123) if (offset === 0) parse(characters, root, reference, reference, props, rulesets, length, points, children);else {\n            switch (atrule) {\n              // c(ontainer)\n              case 99:\n                if (charat(characters, 3) === 110) break;\n              // l(ayer)\n              case 108:\n                if (charat(characters, 2) === 97) break;\n              default:\n                offset = 0;\n              // d(ocument) m(edia) s(upports)\n              case 100:\n              case 109:\n              case 115:\n            }\n            if (offset) parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length, children), children), rules, children, length, points, rule ? props : children);else parse(characters, reference, reference, reference, [''], children, 0, points, children);\n          }\n      }\n      index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo;\n      break;\n    // :\n    case 58:\n      length = 1 + strlen(characters), property = previous;\n    default:\n      if (variable < 1) if (character == 123) --variable;else if (character == 125 && variable++ == 0 && prev() == 125) continue;\n      switch (characters += from(character), character * variable) {\n        // &\n        case 38:\n          ampersand = offset > 0 ? 1 : (characters += '\\f', -1);\n          break;\n        // ,\n        case 44:\n          points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;\n          break;\n        // @\n        case 64:\n          // -\n          if (peek() === 45) characters += delimit(next());\n          atrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++;\n          break;\n        // -\n        case 45:\n          if (previous === 45 && strlen(characters) == 2) variable = 0;\n      }\n  }\n  return rulesets;\n}\n\n/**\r\n * @param {string} value\r\n * @param {object} root\r\n * @param {object?} parent\r\n * @param {number} index\r\n * @param {number} offset\r\n * @param {string[]} rules\r\n * @param {number[]} points\r\n * @param {string} type\r\n * @param {string[]} props\r\n * @param {string[]} children\r\n * @param {number} length\r\n * @param {object[]} siblings\r\n * @return {object}\r\n */\nexport function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length, siblings) {\n  var post = offset - 1;\n  var rule = offset === 0 ? rules : [''];\n  var size = sizeof(rule);\n  for (var i = 0, j = 0, k = 0; i < index; ++i) for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x) if (z = trim(j > 0 ? rule[x] + ' ' + y : replace(y, /&\\f/g, rule[x]))) props[k++] = z;\n  return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length, siblings);\n}\n\n/**\r\n * @param {number} value\r\n * @param {object} root\r\n * @param {object?} parent\r\n * @param {object[]} siblings\r\n * @return {object}\r\n */\nexport function comment(value, root, parent, siblings) {\n  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);\n}\n\n/**\r\n * @param {string} value\r\n * @param {object} root\r\n * @param {object?} parent\r\n * @param {number} length\r\n * @param {object[]} siblings\r\n * @return {object}\r\n */\nexport function declaration(value, root, parent, length, siblings) {\n  return node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length, siblings);\n}","map":{"version":3,"names":["COMMENT","RULESET","DECLARATION","abs","charat","trim","from","sizeof","strlen","substr","append","replace","indexof","node","char","prev","next","peek","token","caret","alloc","dealloc","delimit","whitespace","escaping","identifier","commenter","compile","value","parse","root","parent","rule","rules","rulesets","pseudo","points","declarations","index","offset","length","atrule","property","previous","variable","scanning","ampersand","character","type","props","children","reference","characters","comment","declaration","ruleset","siblings","post","size","i","j","k","x","y","z"],"sources":["E:/AICode/StockInsight/frontend/node_modules/stylis/src/Parser.js"],"sourcesContent":["import {COMMENT, RULESET, DECLARATION} from './Enum.js'\r\nimport {abs, charat, trim, from, sizeof, strlen, substr, append, replace, indexof} from './Utility.js'\r\nimport {node, char, prev, next, peek, token, caret, alloc, dealloc, delimit, whitespace, escaping, identifier, commenter} from './Tokenizer.js'\r\n\r\n/**\r\n * @param {string} value\r\n * @return {object[]}\r\n */\r\nexport function compile (value) {\r\n\treturn dealloc(parse('', null, null, null, [''], value = alloc(value), 0, [0], value))\r\n}\r\n\r\n/**\r\n * @param {string} value\r\n * @param {object} root\r\n * @param {object?} parent\r\n * @param {string[]} rule\r\n * @param {string[]} rules\r\n * @param {string[]} rulesets\r\n * @param {number[]} pseudo\r\n * @param {number[]} points\r\n * @param {string[]} declarations\r\n * @return {object}\r\n */\r\nexport function parse (value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {\r\n\tvar index = 0\r\n\tvar offset = 0\r\n\tvar length = pseudo\r\n\tvar atrule = 0\r\n\tvar property = 0\r\n\tvar previous = 0\r\n\tvar variable = 1\r\n\tvar scanning = 1\r\n\tvar ampersand = 1\r\n\tvar character = 0\r\n\tvar type = ''\r\n\tvar props = rules\r\n\tvar children = rulesets\r\n\tvar reference = rule\r\n\tvar characters = type\r\n\r\n\twhile (scanning)\r\n\t\tswitch (previous = character, character = next()) {\r\n\t\t\t// (\r\n\t\t\tcase 40:\r\n\t\t\t\tif (previous != 108 && charat(characters, length - 1) == 58) {\r\n\t\t\t\t\tif (indexof(characters += replace(delimit(character), '&', '&\\f'), '&\\f', abs(index ? points[index - 1] : 0)) != -1)\r\n\t\t\t\t\t\tampersand = -1\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t// \" ' [\r\n\t\t\tcase 34: case 39: case 91:\r\n\t\t\t\tcharacters += delimit(character)\r\n\t\t\t\tbreak\r\n\t\t\t// \\t \\n \\r \\s\r\n\t\t\tcase 9: case 10: case 13: case 32:\r\n\t\t\t\tcharacters += whitespace(previous)\r\n\t\t\t\tbreak\r\n\t\t\t// \\\r\n\t\t\tcase 92:\r\n\t\t\t\tcharacters += escaping(caret() - 1, 7)\r\n\t\t\t\tcontinue\r\n\t\t\t// /\r\n\t\t\tcase 47:\r\n\t\t\t\tswitch (peek()) {\r\n\t\t\t\t\tcase 42: case 47:\r\n\t\t\t\t\t\tappend(comment(commenter(next(), caret()), root, parent, declarations), declarations)\r\n\t\t\t\t\t\tif ((token(previous || 1) == 5 || token(peek() || 1) == 5) && strlen(characters) && substr(characters, -1, void 0) !== ' ') characters += ' '\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tcharacters += '/'\r\n\t\t\t\t}\r\n\t\t\t\tbreak\r\n\t\t\t// {\r\n\t\t\tcase 123 * variable:\r\n\t\t\t\tpoints[index++] = strlen(characters) * ampersand\r\n\t\t\t// } ; \\0\r\n\t\t\tcase 125 * variable: case 59: case 0:\r\n\t\t\t\tswitch (character) {\r\n\t\t\t\t\t// \\0 }\r\n\t\t\t\t\tcase 0: case 125: scanning = 0\r\n\t\t\t\t\t// ;\r\n\t\t\t\t\tcase 59 + offset: if (ampersand == -1) characters = replace(characters, /\\f/g, '')\r\n\t\t\t\t\t\tif (property > 0 && (strlen(characters) - length || (variable === 0 && previous === 47)))\r\n\t\t\t\t\t\t\tappend(property > 32 ? declaration(characters + ';', rule, parent, length - 1, declarations) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2, declarations), declarations)\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t// @ ;\r\n\t\t\t\t\tcase 59: characters += ';'\r\n\t\t\t\t\t// { rule/at-rule\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tappend(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length, rulesets), rulesets)\r\n\r\n\t\t\t\t\t\tif (character === 123)\r\n\t\t\t\t\t\t\tif (offset === 0)\r\n\t\t\t\t\t\t\t\tparse(characters, root, reference, reference, props, rulesets, length, points, children)\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tswitch (atrule) {\r\n\t\t\t\t\t\t\t\t\t// c(ontainer)\r\n\t\t\t\t\t\t\t\t\tcase 99:\r\n\t\t\t\t\t\t\t\t\t\tif (charat(characters, 3) === 110) break\r\n\t\t\t\t\t\t\t\t\t// l(ayer)\r\n\t\t\t\t\t\t\t\t\tcase 108:\r\n\t\t\t\t\t\t\t\t\t\tif (charat(characters, 2) === 97) break\r\n\t\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\t\toffset = 0\r\n\t\t\t\t\t\t\t\t\t// d(ocument) m(edia) s(upports)\r\n\t\t\t\t\t\t\t\t\tcase 100: case 109: case 115:\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (offset) parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length, children), children), rules, children, length, points, rule ? props : children)\r\n\t\t\t\t\t\t\t\telse parse(characters, reference, reference, reference, [''], children, 0, points, children)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tindex = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo\r\n\t\t\t\tbreak\r\n\t\t\t// :\r\n\t\t\tcase 58:\r\n\t\t\t\tlength = 1 + strlen(characters), property = previous\r\n\t\t\tdefault:\r\n\t\t\t\tif (variable < 1)\r\n\t\t\t\t\tif (character == 123)\r\n\t\t\t\t\t\t--variable\r\n\t\t\t\t\telse if (character == 125 && variable++ == 0 && prev() == 125)\r\n\t\t\t\t\t\tcontinue\r\n\r\n\t\t\t\tswitch (characters += from(character), character * variable) {\r\n\t\t\t\t\t// &\r\n\t\t\t\t\tcase 38:\r\n\t\t\t\t\t\tampersand = offset > 0 ? 1 : (characters += '\\f', -1)\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t// ,\r\n\t\t\t\t\tcase 44:\r\n\t\t\t\t\t\tpoints[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t// @\r\n\t\t\t\t\tcase 64:\r\n\t\t\t\t\t\t// -\r\n\t\t\t\t\t\tif (peek() === 45)\r\n\t\t\t\t\t\t\tcharacters += delimit(next())\r\n\r\n\t\t\t\t\t\tatrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t// -\r\n\t\t\t\t\tcase 45:\r\n\t\t\t\t\t\tif (previous === 45 && strlen(characters) == 2)\r\n\t\t\t\t\t\t\tvariable = 0\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\treturn rulesets\r\n}\r\n\r\n/**\r\n * @param {string} value\r\n * @param {object} root\r\n * @param {object?} parent\r\n * @param {number} index\r\n * @param {number} offset\r\n * @param {string[]} rules\r\n * @param {number[]} points\r\n * @param {string} type\r\n * @param {string[]} props\r\n * @param {string[]} children\r\n * @param {number} length\r\n * @param {object[]} siblings\r\n * @return {object}\r\n */\r\nexport function ruleset (value, root, parent, index, offset, rules, points, type, props, children, length, siblings) {\r\n\tvar post = offset - 1\r\n\tvar rule = offset === 0 ? rules : ['']\r\n\tvar size = sizeof(rule)\r\n\r\n\tfor (var i = 0, j = 0, k = 0; i < index; ++i)\r\n\t\tfor (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)\r\n\t\t\tif (z = trim(j > 0 ? rule[x] + ' ' + y : replace(y, /&\\f/g, rule[x])))\r\n\t\t\t\tprops[k++] = z\r\n\r\n\treturn node(value, root, parent, offset === 0 ? RULESET : type, props, children, length, siblings)\r\n}\r\n\r\n/**\r\n * @param {number} value\r\n * @param {object} root\r\n * @param {object?} parent\r\n * @param {object[]} siblings\r\n * @return {object}\r\n */\r\nexport function comment (value, root, parent, siblings) {\r\n\treturn node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings)\r\n}\r\n\r\n/**\r\n * @param {string} value\r\n * @param {object} root\r\n * @param {object?} parent\r\n * @param {number} length\r\n * @param {object[]} siblings\r\n * @return {object}\r\n */\r\nexport function declaration (value, root, parent, length, siblings) {\r\n\treturn node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length, siblings)\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}