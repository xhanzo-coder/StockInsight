{"ast":null,"code":"/**\n * 认证服务\n * 处理用户登录、注册、令牌管理等功能\n * 增强的错误处理和重试机制\n */import axios from'axios';import{message}from'antd';import{tokenManager}from'./api';// 认证API基础URL\nconst AUTH_API_URL='http://localhost:5000/api/auth';// 本地存储键\nconst USER_INFO_KEY='userInfo';const AUTH_LAST_VERIFIED_KEY='auth_last_verified';// 配置常量\nconst REQUEST_TIMEOUT=15000;// 请求超时时间（毫秒）\nconst MAX_RETRY_COUNT=2;// 最大重试次数\nconst RETRY_DELAY=1000;// 重试延迟（毫秒）\n// 创建认证专用的 axios 实例\nconst authApi=axios.create({baseURL:AUTH_API_URL,timeout:REQUEST_TIMEOUT,headers:{'Content-Type':'application/json'}});// 请求重试函数\nconst retryAuthRequest=async function(config){let retryCount=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;try{return await axios(config);}catch(error){// 只有在网络错误或5xx服务器错误时重试\nconst isNetworkError=!error.response;const isServerError=error.response&&error.response.status>=500;if((isNetworkError||isServerError)&&retryCount<MAX_RETRY_COUNT){console.log(`认证请求失败，${RETRY_DELAY/1000}秒后重试 (${retryCount+1}/${MAX_RETRY_COUNT})`);await new Promise(resolve=>setTimeout(resolve,RETRY_DELAY));return retryAuthRequest(config,retryCount+1);}throw error;}};// 添加请求拦截器 - 自动添加token到请求头\nauthApi.interceptors.request.use(config=>{const token=tokenManager.getToken();if(token){config.headers=config.headers||{};config.headers.Authorization=`Bearer ${token}`;}// 添加请求时间戳，用于调试\nconfig.headers=config.headers||{};config.headers['X-Request-Time']=new Date().toISOString();// 记录请求信息（调试模式）\nif(process.env.NODE_ENV==='development'){var _config$method;console.log(`🔐 认证请求: ${(_config$method=config.method)===null||_config$method===void 0?void 0:_config$method.toUpperCase()} ${config.url}`,{headers:{...config.headers,Authorization:token?'已设置':'未设置'},data:config.data,params:config.params});}return config;},error=>{console.error('认证请求拦截器错误:',error);return Promise.reject(error);});// 添加响应拦截器 - 处理token过期\nauthApi.interceptors.response.use(response=>{// 记录响应信息（调试模式）\nif(process.env.NODE_ENV==='development'){var _response$config$meth;console.log(`✅ 认证响应成功: ${(_response$config$meth=response.config.method)===null||_response$config$meth===void 0?void 0:_response$config$meth.toUpperCase()} ${response.config.url}`,{status:response.status,data:response.data});}return response;},error=>{// 获取请求配置和响应\nconst{config,response}=error;// 记录错误信息（调试模式）\nif(process.env.NODE_ENV==='development'){var _config$method2;console.error(`❌ 认证请求失败: ${config===null||config===void 0?void 0:(_config$method2=config.method)===null||_config$method2===void 0?void 0:_config$method2.toUpperCase()} ${config===null||config===void 0?void 0:config.url}`,{status:response===null||response===void 0?void 0:response.status,data:response===null||response===void 0?void 0:response.data,error:error.message});}// 处理401错误（未授权，通常是token过期或无效）\nif((response===null||response===void 0?void 0:response.status)===401){console.warn('认证请求收到401未授权响应');// 清除认证相关数据\ntokenManager.removeToken();localStorage.removeItem(USER_INFO_KEY);localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);// 如果不是验证接口的请求，显示提示并重定向\nif((config===null||config===void 0?void 0:config.url)!=='/verify'){message.error('登录已过期，请重新登录');// 使用延迟重定向，确保消息能够显示\nsetTimeout(()=>{// 保存当前URL，以便登录后返回\nconst currentPath=window.location.pathname;if(currentPath!=='/login'){sessionStorage.setItem('redirectAfterLogin',currentPath);}window.location.href='/login';},1500);}}return Promise.reject(error);});// 用户数据类型\n// 登录请求数据\n// 注册请求数据\n// 认证响应数据\n// API 响应格式\n// 认证服务类\nexport class AuthService{/**\n   * 用户注册\n   */async register(userData){try{// 使用重试机制发送请求\nconst response=await retryAuthRequest({method:'post',url:`${AUTH_API_URL}/register`,data:userData,headers:{'Content-Type':'application/json'}});const data=response.data;if(data.success&&data.data){// 保存令牌 - 后端返回的是token字段\ntokenManager.setToken(data.data.token);// 保存用户信息和验证时间\nlocalStorage.setItem(USER_INFO_KEY,JSON.stringify(data.data.user));localStorage.setItem(AUTH_LAST_VERIFIED_KEY,Date.now().toString());message.success('注册成功！');return data;}else{message.error(data.message||'注册失败');return data;}}catch(error){var _error$response,_error$response2,_error$response2$data;console.error('注册失败:',((_error$response=error.response)===null||_error$response===void 0?void 0:_error$response.data)||error.message);// 检查是否为网络错误\nconst isNetworkError=!error.response;if(isNetworkError){const errorMessage='网络连接错误，请检查网络连接';message.error(errorMessage);return{success:false,message:errorMessage,networkError:true};}const errorMessage=((_error$response2=error.response)===null||_error$response2===void 0?void 0:(_error$response2$data=_error$response2.data)===null||_error$response2$data===void 0?void 0:_error$response2$data.message)||'注册失败，请重试';message.error(errorMessage);return{success:false,message:errorMessage,error:error.message};}}/**\n   * 用户登录\n   */async login(credentials){try{console.log('开始登录请求:',credentials);console.log('API URL:',AUTH_API_URL);// 使用重试机制发送请求\nconst response=await retryAuthRequest({method:'post',url:`${AUTH_API_URL}/login`,data:credentials,headers:{'Content-Type':'application/json'}});console.log('登录响应:',response.data);const data=response.data;if(data.success&&data.data){// 保存令牌到localStorage - 后端返回的是token字段\ntokenManager.setToken(data.data.token);// 保存用户信息和验证时间\nlocalStorage.setItem(USER_INFO_KEY,JSON.stringify(data.data.user));localStorage.setItem(AUTH_LAST_VERIFIED_KEY,Date.now().toString());// 检查是否有登录后重定向路径\nconst redirectPath=sessionStorage.getItem('redirectAfterLogin');if(redirectPath){console.log(`登录成功，将重定向到: ${redirectPath}`);sessionStorage.removeItem('redirectAfterLogin');}message.success('登录成功！');return data;}else{console.error('登录失败:',data.message);message.error(data.message||'登录失败');return data;}}catch(error){var _error$response3,_error$response4,_error$response5,_error$response5$data;console.error('登录请求异常:',error);console.error('错误响应:',(_error$response3=error.response)===null||_error$response3===void 0?void 0:_error$response3.data);// 检查是否为网络错误\nconst isNetworkError=!error.response;if(isNetworkError){const errorMessage='网络连接错误，请检查网络连接';message.error(errorMessage);return{success:false,message:errorMessage,networkError:true};}// 处理特定错误\nif(((_error$response4=error.response)===null||_error$response4===void 0?void 0:_error$response4.status)===401){const errorMessage='用户名或密码错误';message.error(errorMessage);return{success:false,message:errorMessage,error:error.message};}const errorMessage=((_error$response5=error.response)===null||_error$response5===void 0?void 0:(_error$response5$data=_error$response5.data)===null||_error$response5$data===void 0?void 0:_error$response5$data.message)||'登录失败，请重试';message.error(errorMessage);return{success:false,message:errorMessage,error:error.message};}}/**\n   * 验证令牌\n   */async verifyToken(){try{const token=tokenManager.getToken();if(!token){console.log('没有找到token，无法验证');return{success:false};}console.log('开始验证token...',token.substring(0,15)+'...');console.log('Token格式检查:',token.split('.').length===3?'有效':'无效');// 直接检查token是否有效\nif(!tokenManager.isAuthenticated()){console.warn('本地token验证失败，可能已过期');tokenManager.removeToken();localStorage.removeItem(USER_INFO_KEY);localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);return{success:false};}// 检查是否有本地存储的用户信息\nconst storedUserInfo=localStorage.getItem(USER_INFO_KEY);let localUser=null;if(storedUserInfo){try{localUser=JSON.parse(storedUserInfo);console.log('从本地存储恢复用户信息:',localUser);}catch(e){console.error('解析本地用户信息失败:',e);}}// 使用重试机制发送请求\nconsole.log(`发送验证请求到: ${AUTH_API_URL}/verify`);const response=await retryAuthRequest({method:'get',url:`${AUTH_API_URL}/verify`,headers:{'Authorization':`Bearer ${token}`,'Content-Type':'application/json'},timeout:5000// 降低超时时间，加快验证速度\n});// 请求拦截器会自动添加Authorization头\nconst data=response.data;console.log('验证响应:',data);if(data.success&&data.data&&data.data.user){console.log('Token验证成功，用户信息:',data.data.user);// 更新验证时间和用户信息\nlocalStorage.setItem(AUTH_LAST_VERIFIED_KEY,Date.now().toString());localStorage.setItem(USER_INFO_KEY,JSON.stringify(data.data.user));return{success:true,user:data.data.user};}else{console.log('Token验证失败，服务器返回:',data);tokenManager.removeToken();localStorage.removeItem(USER_INFO_KEY);localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);return{success:false};}}catch(error){var _error$response6,_error$response7;console.error('令牌验证失败:',error);console.error('错误状态码:',(_error$response6=error.response)===null||_error$response6===void 0?void 0:_error$response6.status);console.error('错误详情:',(_error$response7=error.response)===null||_error$response7===void 0?void 0:_error$response7.data);// 检查是否为网络错误\nconst isNetworkError=!error.response;if(isNetworkError){console.warn('验证token: 网络错误，检查本地用户信息');// 网络错误时，如果有本地用户信息，尝试使用本地信息\nconst storedUserInfo=localStorage.getItem(USER_INFO_KEY);if(storedUserInfo&&tokenManager.isAuthenticated()){try{const user=JSON.parse(storedUserInfo);console.log('网络错误，使用本地用户信息:',user);return{success:true,user:user,networkError:true};}catch(e){console.error('解析本地用户信息失败:',e);}}return{success:false,networkError:true};}// 清除无效的token（除非是网络错误）\nif(!isNetworkError){tokenManager.removeToken();localStorage.removeItem(USER_INFO_KEY);localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);}return{success:false};}}/**\n   * 获取用户资料\n   */async getProfile(){try{const token=tokenManager.getToken();if(!token){return{success:false};}// 使用重试机制发送请求\nconst response=await retryAuthRequest({method:'get',url:`${AUTH_API_URL}/profile`,headers:{'Authorization':`Bearer ${token}`,'Content-Type':'application/json'}});// 请求拦截器会自动添加Authorization头\nconst data=response.data;if(data.success&&data.data&&data.data.user){// 更新用户信息和验证时间\nlocalStorage.setItem(USER_INFO_KEY,JSON.stringify(data.data.user));localStorage.setItem(AUTH_LAST_VERIFIED_KEY,Date.now().toString());return{success:true,user:data.data.user};}else{return{success:false};}}catch(error){var _error$response8;console.error('获取用户资料失败:',error);// 检查是否为网络错误\nconst isNetworkError=!error.response;if(isNetworkError){return{success:false,networkError:true};}// 如果是401错误，清除认证状态\nif(((_error$response8=error.response)===null||_error$response8===void 0?void 0:_error$response8.status)===401){tokenManager.removeToken();localStorage.removeItem(USER_INFO_KEY);localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);}return{success:false};}}/**\n   * 用户登出\n   */async logout(){try{const token=tokenManager.getToken();if(token){try{// 可选：调用后端登出接口\nawait authApi.post('/logout');// 注意：由于添加了请求拦截器，这里不需要手动添加Authorization头\nconsole.log('成功调用登出API');}catch(error){console.warn('登出API调用失败，但会继续清除本地状态:',error);}}// 无论如何都要清除本地令牌和用户信息\ntokenManager.removeToken();localStorage.removeItem(USER_INFO_KEY);localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);return{success:true,message:'已安全退出登录'};}catch(error){console.error('登出过程出错:',error);// 即使出错，也要尝试清除本地状态\ntry{tokenManager.removeToken();localStorage.removeItem(USER_INFO_KEY);localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);}catch(e){console.error('清除本地状态失败:',e);}return{success:false,message:'登出过程出错，但已清除本地登录状态'};}}/**\n   * 检查是否已认证\n   */isAuthenticated(){return tokenManager.isAuthenticated();}/**\n   * 检查认证状态（本地检查，不发送网络请求）\n   */checkAuthStatus(){const isAuthenticated=this.isAuthenticated();let user=null;// 如果有token，尝试从localStorage获取用户信息\nif(isAuthenticated){try{const userInfo=localStorage.getItem(USER_INFO_KEY);if(userInfo){user=JSON.parse(userInfo);}}catch(e){console.error('解析用户信息失败:',e);}}return{isAuthenticated,user};}}export const authService=new AuthService();","map":{"version":3,"names":["axios","message","tokenManager","AUTH_API_URL","USER_INFO_KEY","AUTH_LAST_VERIFIED_KEY","REQUEST_TIMEOUT","MAX_RETRY_COUNT","RETRY_DELAY","authApi","create","baseURL","timeout","headers","retryAuthRequest","config","retryCount","arguments","length","undefined","error","isNetworkError","response","isServerError","status","console","log","Promise","resolve","setTimeout","interceptors","request","use","token","getToken","Authorization","Date","toISOString","process","env","NODE_ENV","_config$method","method","toUpperCase","url","data","params","reject","_response$config$meth","_config$method2","warn","removeToken","localStorage","removeItem","currentPath","window","location","pathname","sessionStorage","setItem","href","AuthService","register","userData","success","setToken","JSON","stringify","user","now","toString","_error$response","_error$response2","_error$response2$data","errorMessage","networkError","login","credentials","redirectPath","getItem","_error$response3","_error$response4","_error$response5","_error$response5$data","verifyToken","substring","split","isAuthenticated","storedUserInfo","localUser","parse","e","_error$response6","_error$response7","getProfile","_error$response8","logout","post","checkAuthStatus","userInfo","authService"],"sources":["E:/AICode/StockInsight/frontend/src/services/authService.ts"],"sourcesContent":["/**\n * 认证服务\n * 处理用户登录、注册、令牌管理等功能\n * 增强的错误处理和重试机制\n */\n\nimport axios, { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';\nimport { message } from 'antd';\nimport { tokenManager } from './api';\n\n// 认证API基础URL\nconst AUTH_API_URL = 'http://localhost:5000/api/auth';\n\n// 本地存储键\nconst USER_INFO_KEY = 'userInfo';\nconst AUTH_LAST_VERIFIED_KEY = 'auth_last_verified';\n\n// 配置常量\nconst REQUEST_TIMEOUT = 15000; // 请求超时时间（毫秒）\nconst MAX_RETRY_COUNT = 2; // 最大重试次数\nconst RETRY_DELAY = 1000; // 重试延迟（毫秒）\n\n// 创建认证专用的 axios 实例\nconst authApi = axios.create({\n  baseURL: AUTH_API_URL,\n  timeout: REQUEST_TIMEOUT,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\n// 请求重试函数\nconst retryAuthRequest = async (config: AxiosRequestConfig, retryCount: number = 0): Promise<AxiosResponse> => {\n  try {\n    return await axios(config);\n  } catch (error: any) {\n    // 只有在网络错误或5xx服务器错误时重试\n    const isNetworkError = !error.response;\n    const isServerError = error.response && error.response.status >= 500;\n    \n    if ((isNetworkError || isServerError) && retryCount < MAX_RETRY_COUNT) {\n      console.log(`认证请求失败，${RETRY_DELAY/1000}秒后重试 (${retryCount + 1}/${MAX_RETRY_COUNT})`);\n      await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));\n      return retryAuthRequest(config, retryCount + 1);\n    }\n    \n    throw error;\n  }\n};\n\n// 添加请求拦截器 - 自动添加token到请求头\nauthApi.interceptors.request.use(\n  (config) => {\n    const token = tokenManager.getToken();\n    if (token) {\n      config.headers = config.headers || {};\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n    \n    // 添加请求时间戳，用于调试\n    config.headers = config.headers || {};\n    config.headers['X-Request-Time'] = new Date().toISOString();\n    \n    // 记录请求信息（调试模式）\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`🔐 认证请求: ${config.method?.toUpperCase()} ${config.url}`, {\n        headers: { ...config.headers, Authorization: token ? '已设置' : '未设置' },\n        data: config.data,\n        params: config.params\n      });\n    }\n    \n    return config;\n  },\n  (error) => {\n    console.error('认证请求拦截器错误:', error);\n    return Promise.reject(error);\n  }\n);\n\n// 添加响应拦截器 - 处理token过期\nauthApi.interceptors.response.use(\n  (response) => {\n    // 记录响应信息（调试模式）\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`✅ 认证响应成功: ${response.config.method?.toUpperCase()} ${response.config.url}`, {\n        status: response.status,\n        data: response.data\n      });\n    }\n    \n    return response;\n  },\n  (error: AxiosError) => {\n    // 获取请求配置和响应\n    const { config, response } = error;\n    \n    // 记录错误信息（调试模式）\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`❌ 认证请求失败: ${config?.method?.toUpperCase()} ${config?.url}`, {\n        status: response?.status,\n        data: response?.data,\n        error: error.message\n      });\n    }\n    \n    // 处理401错误（未授权，通常是token过期或无效）\n    if (response?.status === 401) {\n      console.warn('认证请求收到401未授权响应');\n      \n      // 清除认证相关数据\n      tokenManager.removeToken();\n      localStorage.removeItem(USER_INFO_KEY);\n      localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      \n      // 如果不是验证接口的请求，显示提示并重定向\n      if (config?.url !== '/verify') {\n        message.error('登录已过期，请重新登录');\n        \n        // 使用延迟重定向，确保消息能够显示\n        setTimeout(() => {\n          // 保存当前URL，以便登录后返回\n          const currentPath = window.location.pathname;\n          if (currentPath !== '/login') {\n            sessionStorage.setItem('redirectAfterLogin', currentPath);\n          }\n          \n          window.location.href = '/login';\n        }, 1500);\n      }\n    }\n    \n    return Promise.reject(error);\n  }\n);\n\n// 用户数据类型\nexport interface User {\n  id: number;\n  username: string;\n  email: string;\n  created_at: string;\n  last_login?: string;\n}\n\n// 登录请求数据\nexport interface LoginRequest {\n  username: string;\n  password: string;\n}\n\n// 注册请求数据\nexport interface RegisterRequest {\n  username: string;\n  email: string;\n  password: string;\n}\n\n// 认证响应数据\nexport interface AuthResponse {\n  user: User;\n  token: string; // 后端返回的是token字段，而不是access_token\n}\n\n// API 响应格式\nexport interface ApiResponse<T> {\n  success: boolean;\n  data?: T;\n  message?: string;\n  error?: string;\n  networkError?: boolean;\n}\n\n// 认证服务类\nexport class AuthService {\n\n  /**\n   * 用户注册\n   */\n  async register(userData: RegisterRequest): Promise<ApiResponse<AuthResponse>> {\n    try {\n      // 使用重试机制发送请求\n      const response = await retryAuthRequest({\n        method: 'post',\n        url: `${AUTH_API_URL}/register`,\n        data: userData,\n        headers: { 'Content-Type': 'application/json' }\n      });\n      \n      const data = response.data;\n\n      if (data.success && data.data) {\n        // 保存令牌 - 后端返回的是token字段\n        tokenManager.setToken(data.data.token);\n        \n        // 保存用户信息和验证时间\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(data.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        \n        message.success('注册成功！');\n        return data;\n      } else {\n        message.error(data.message || '注册失败');\n        return data;\n      }\n    } catch (error: any) {\n      console.error('注册失败:', error.response?.data || error.message);\n      \n      // 检查是否为网络错误\n      const isNetworkError = !error.response;\n      if (isNetworkError) {\n        const errorMessage = '网络连接错误，请检查网络连接';\n        message.error(errorMessage);\n        return {\n          success: false,\n          message: errorMessage,\n          networkError: true\n        };\n      }\n      \n      const errorMessage = error.response?.data?.message || '注册失败，请重试';\n      message.error(errorMessage);\n      return {\n        success: false,\n        message: errorMessage,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * 用户登录\n   */\n  async login(credentials: LoginRequest): Promise<ApiResponse<AuthResponse>> {\n    try {\n      console.log('开始登录请求:', credentials);\n      console.log('API URL:', AUTH_API_URL);\n      \n      // 使用重试机制发送请求\n      const response = await retryAuthRequest({\n        method: 'post',\n        url: `${AUTH_API_URL}/login`,\n        data: credentials,\n        headers: { 'Content-Type': 'application/json' }\n      });\n      \n      console.log('登录响应:', response.data);\n      \n      const data = response.data;\n\n      if (data.success && data.data) {\n        // 保存令牌到localStorage - 后端返回的是token字段\n        tokenManager.setToken(data.data.token);\n        \n        // 保存用户信息和验证时间\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(data.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        \n        // 检查是否有登录后重定向路径\n        const redirectPath = sessionStorage.getItem('redirectAfterLogin');\n        if (redirectPath) {\n          console.log(`登录成功，将重定向到: ${redirectPath}`);\n          sessionStorage.removeItem('redirectAfterLogin');\n        }\n        \n        message.success('登录成功！');\n        return data;\n      } else {\n        console.error('登录失败:', data.message);\n        message.error(data.message || '登录失败');\n        return data;\n      }\n    } catch (error: any) {\n      console.error('登录请求异常:', error);\n      console.error('错误响应:', error.response?.data);\n      \n      // 检查是否为网络错误\n      const isNetworkError = !error.response;\n      if (isNetworkError) {\n        const errorMessage = '网络连接错误，请检查网络连接';\n        message.error(errorMessage);\n        return {\n          success: false,\n          message: errorMessage,\n          networkError: true\n        };\n      }\n      \n      // 处理特定错误\n      if (error.response?.status === 401) {\n        const errorMessage = '用户名或密码错误';\n        message.error(errorMessage);\n        return {\n          success: false,\n          message: errorMessage,\n          error: error.message\n        };\n      }\n      \n      const errorMessage = error.response?.data?.message || '登录失败，请重试';\n      message.error(errorMessage);\n      return {\n        success: false,\n        message: errorMessage,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * 验证令牌\n   */\n  async verifyToken(): Promise<{ success: boolean; user?: User; networkError?: boolean }> {\n    try {\n      const token = tokenManager.getToken();\n      if (!token) {\n        console.log('没有找到token，无法验证');\n        return { success: false };\n      }\n\n      console.log('开始验证token...', token.substring(0, 15) + '...');\n      console.log('Token格式检查:', token.split('.').length === 3 ? '有效' : '无效');\n      \n      // 直接检查token是否有效\n      if (!tokenManager.isAuthenticated()) {\n        console.warn('本地token验证失败，可能已过期');\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n        return { success: false };\n      }\n      \n      // 检查是否有本地存储的用户信息\n      const storedUserInfo = localStorage.getItem(USER_INFO_KEY);\n      let localUser: User | null = null;\n      \n      if (storedUserInfo) {\n        try {\n          localUser = JSON.parse(storedUserInfo);\n          console.log('从本地存储恢复用户信息:', localUser);\n        } catch (e) {\n          console.error('解析本地用户信息失败:', e);\n        }\n      }\n      \n      // 使用重试机制发送请求\n      console.log(`发送验证请求到: ${AUTH_API_URL}/verify`);\n      const response = await retryAuthRequest({\n        method: 'get',\n        url: `${AUTH_API_URL}/verify`,\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        },\n        timeout: 5000 // 降低超时时间，加快验证速度\n      });\n      \n      // 请求拦截器会自动添加Authorization头\n      const data = response.data;\n      console.log('验证响应:', data);\n      \n      if (data.success && data.data && data.data.user) {\n        console.log('Token验证成功，用户信息:', data.data.user);\n        \n        // 更新验证时间和用户信息\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(data.data.user));\n        \n        return { success: true, user: data.data.user };\n      } else {\n        console.log('Token验证失败，服务器返回:', data);\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n        return { success: false };\n      }\n    } catch (error: any) {\n      console.error('令牌验证失败:', error);\n      console.error('错误状态码:', error.response?.status);\n      console.error('错误详情:', error.response?.data);\n      \n      // 检查是否为网络错误\n      const isNetworkError = !error.response;\n      if (isNetworkError) {\n        console.warn('验证token: 网络错误，检查本地用户信息');\n        \n        // 网络错误时，如果有本地用户信息，尝试使用本地信息\n        const storedUserInfo = localStorage.getItem(USER_INFO_KEY);\n        if (storedUserInfo && tokenManager.isAuthenticated()) {\n          try {\n            const user = JSON.parse(storedUserInfo);\n            console.log('网络错误，使用本地用户信息:', user);\n            return {\n              success: true,\n              user: user,\n              networkError: true\n            };\n          } catch (e) {\n            console.error('解析本地用户信息失败:', e);\n          }\n        }\n        \n        return {\n          success: false,\n          networkError: true\n        };\n      }\n      \n      // 清除无效的token（除非是网络错误）\n      if (!isNetworkError) {\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      }\n      \n      return { success: false };\n    }\n  }\n\n  /**\n   * 获取用户资料\n   */\n  async getProfile(): Promise<{ success: boolean; user?: User; networkError?: boolean }> {\n    try {\n      const token = tokenManager.getToken();\n      if (!token) {\n        return { success: false };\n      }\n\n      // 使用重试机制发送请求\n      const response = await retryAuthRequest({\n        method: 'get',\n        url: `${AUTH_API_URL}/profile`,\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n      \n      // 请求拦截器会自动添加Authorization头\n      const data = response.data;\n      \n      if (data.success && data.data && data.data.user) {\n        // 更新用户信息和验证时间\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(data.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        \n        return { success: true, user: data.data.user };\n      } else {\n        return { success: false };\n      }\n    } catch (error: any) {\n      console.error('获取用户资料失败:', error);\n      \n      // 检查是否为网络错误\n      const isNetworkError = !error.response;\n      if (isNetworkError) {\n        return {\n          success: false,\n          networkError: true\n        };\n      }\n      \n      // 如果是401错误，清除认证状态\n      if (error.response?.status === 401) {\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      }\n      \n      return { success: false };\n    }\n  }\n\n  /**\n   * 用户登出\n   */\n  async logout(): Promise<{ success: boolean; message?: string }> {\n    try {\n      const token = tokenManager.getToken();\n      if (token) {\n        try {\n          // 可选：调用后端登出接口\n          await authApi.post('/logout');\n          // 注意：由于添加了请求拦截器，这里不需要手动添加Authorization头\n          console.log('成功调用登出API');\n        } catch (error) {\n          console.warn('登出API调用失败，但会继续清除本地状态:', error);\n        }\n      }\n      \n      // 无论如何都要清除本地令牌和用户信息\n      tokenManager.removeToken();\n      localStorage.removeItem(USER_INFO_KEY);\n      localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      \n      return { success: true, message: '已安全退出登录' };\n    } catch (error: any) {\n      console.error('登出过程出错:', error);\n      \n      // 即使出错，也要尝试清除本地状态\n      try {\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      } catch (e) {\n        console.error('清除本地状态失败:', e);\n      }\n      \n      return {\n        success: false,\n        message: '登出过程出错，但已清除本地登录状态'\n      };\n    }\n  }\n\n  /**\n   * 检查是否已认证\n   */\n  isAuthenticated(): boolean {\n    return tokenManager.isAuthenticated();\n  }\n  \n  /**\n   * 检查认证状态（本地检查，不发送网络请求）\n   */\n  checkAuthStatus(): { isAuthenticated: boolean; user: User | null } {\n    const isAuthenticated = this.isAuthenticated();\n    let user: User | null = null;\n    \n    // 如果有token，尝试从localStorage获取用户信息\n    if (isAuthenticated) {\n      try {\n        const userInfo = localStorage.getItem(USER_INFO_KEY);\n        if (userInfo) {\n          user = JSON.parse(userInfo);\n        }\n      } catch (e) {\n        console.error('解析用户信息失败:', e);\n      }\n    }\n    \n    return { isAuthenticated, user };\n  }\n}\n\nexport const authService = new AuthService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}