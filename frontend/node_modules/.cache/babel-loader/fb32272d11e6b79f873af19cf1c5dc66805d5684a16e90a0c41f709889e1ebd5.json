{"ast":null,"code":"var _jsxFileName = \"E:\\\\AICode\\\\StockInsight\\\\frontend\\\\src\\\\contexts\\\\AuthContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n/**\n * 认证上下文\n * 提供全局的用户状态管理\n * 使用 useReducer 管理复杂状态，提供更健壮的认证机制\n */\n\nimport React, { createContext, useContext, useEffect, useReducer } from 'react';\nimport { message } from 'antd';\nimport { authService } from '../services/authService';\nimport { tokenManager } from '../services/api';\n\n// 认证状态类型\n\n// 认证操作类型\n\n// 认证上下文类型\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// 创建认证上下文\nconst AuthContext = /*#__PURE__*/createContext(undefined);\n\n// 初始状态\nconst initialState = {\n  user: null,\n  isAuthenticated: false,\n  isLoading: true,\n  error: null,\n  lastVerified: null,\n  tokenRefreshInProgress: false,\n  networkError: false\n};\n\n// 认证状态reducer\nconst authReducer = (state, action) => {\n  switch (action.type) {\n    case 'AUTH_INIT':\n      return {\n        ...state,\n        isLoading: true,\n        error: null,\n        networkError: false\n      };\n    case 'AUTH_SUCCESS':\n      return {\n        ...state,\n        user: action.payload.user,\n        isAuthenticated: true,\n        isLoading: false,\n        error: null,\n        lastVerified: Date.now(),\n        networkError: false\n      };\n    case 'AUTH_FAILURE':\n      return {\n        ...state,\n        user: null,\n        isAuthenticated: false,\n        isLoading: false,\n        error: action.payload.error,\n        lastVerified: Date.now()\n      };\n    case 'AUTH_RESET':\n      return {\n        ...initialState,\n        isLoading: false\n      };\n    case 'SET_LOADING':\n      return {\n        ...state,\n        isLoading: action.payload.isLoading\n      };\n    case 'SET_NETWORK_ERROR':\n      return {\n        ...state,\n        networkError: action.payload.networkError\n      };\n    case 'TOKEN_REFRESH_START':\n      return {\n        ...state,\n        tokenRefreshInProgress: true\n      };\n    case 'TOKEN_REFRESH_END':\n      return {\n        ...state,\n        tokenRefreshInProgress: false\n      };\n    default:\n      return state;\n  }\n};\n\n// 本地存储键\nconst USER_INFO_KEY = 'userInfo';\nconst AUTH_LAST_VERIFIED_KEY = 'auth_last_verified';\n\n// 认证提供者组件\n\nexport const AuthProvider = ({\n  children\n}) => {\n  _s();\n  const [state, dispatch] = useReducer(authReducer, initialState);\n\n  // 验证会话有效性\n  const verifySession = async () => {\n    // 如果没有token，直接返回false\n    const token = tokenManager.getToken();\n    if (!token) {\n      console.log('没有找到token，会话无效');\n      return false;\n    }\n\n    // 检查token格式是否有效\n    const tokenParts = token.split('.');\n    if (tokenParts.length !== 3) {\n      console.warn('token格式无效，清除认证状态');\n      await handleLogout(false);\n      return false;\n    }\n\n    // 如果正在刷新token，等待完成\n    if (state.tokenRefreshInProgress) {\n      console.log('token刷新进行中，使用当前认证状态');\n      return state.isAuthenticated;\n    }\n\n    // 检查token是否过期（通过解析JWT的payload）\n    try {\n      const payload = JSON.parse(atob(tokenParts[1]));\n      if (payload.exp && payload.exp * 1000 < Date.now()) {\n        console.warn('token已过期，清除认证状态');\n        await handleLogout(false);\n        return false;\n      }\n    } catch (e) {\n      console.warn('无法解析token payload:', e);\n      // 继续验证，让服务器决定token是否有效\n    }\n\n    // 检查上次验证时间，如果在5分钟内验证过，直接返回当前状态\n    const lastVerified = state.lastVerified || Number(localStorage.getItem(AUTH_LAST_VERIFIED_KEY)) || 0;\n    const now = Date.now();\n    const fiveMinutes = 5 * 60 * 1000;\n    if (now - lastVerified < fiveMinutes && state.user) {\n      console.log('会话在5分钟内已验证，跳过验证，直接使用当前状态');\n      // 确保状态是已认证的\n      if (!state.isAuthenticated && state.user) {\n        console.log('状态不一致，更新认证状态为已认证');\n        dispatch({\n          type: 'AUTH_SUCCESS',\n          payload: {\n            user: state.user\n          }\n        });\n      }\n      return true;\n    }\n\n    // 开始验证token\n    console.log('开始验证token...');\n    dispatch({\n      type: 'TOKEN_REFRESH_START'\n    });\n    try {\n      console.log('验证会话有效性...');\n      const result = await authService.verifyToken();\n      if (result.success && result.user) {\n        // 更新用户信息和验证时间\n        console.log('会话验证成功，更新用户信息');\n        dispatch({\n          type: 'AUTH_SUCCESS',\n          payload: {\n            user: result.user\n          }\n        });\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        return true;\n      } else if (result.networkError) {\n        // 网络错误时，如果有用户信息，保持认证状态\n        console.warn('网络错误，检查本地用户信息');\n        const storedUserInfo = localStorage.getItem(USER_INFO_KEY);\n        if (storedUserInfo) {\n          try {\n            const parsedUserInfo = JSON.parse(storedUserInfo);\n            console.log('使用本地存储的用户信息:', parsedUserInfo);\n            dispatch({\n              type: 'AUTH_SUCCESS',\n              payload: {\n                user: parsedUserInfo\n              }\n            });\n            dispatch({\n              type: 'SET_NETWORK_ERROR',\n              payload: {\n                networkError: true\n              }\n            });\n            return true;\n          } catch (e) {\n            console.error('解析本地用户信息失败:', e);\n          }\n        }\n        // 没有可用的用户信息，标记网络错误\n        dispatch({\n          type: 'SET_NETWORK_ERROR',\n          payload: {\n            networkError: true\n          }\n        });\n        message.error('网络连接错误，请检查网络连接');\n        return state.isAuthenticated; // 网络错误时保持当前状态\n      } else {\n        // 验证失败，清除状态\n        console.warn('会话验证失败，清除认证状态');\n        await handleLogout(false);\n        return false;\n      }\n    } catch (error) {\n      console.error('会话验证出错:', error);\n\n      // 网络错误时不清除本地状态，但标记网络错误\n      if (error instanceof Error && error.message.includes('Network Error')) {\n        console.warn('网络错误，保持当前认证状态');\n        dispatch({\n          type: 'SET_NETWORK_ERROR',\n          payload: {\n            networkError: true\n          }\n        });\n        message.error('网络连接错误，请检查网络连接');\n        return state.isAuthenticated; // 网络错误时保持当前状态\n      }\n\n      // 其他错误清除状态\n      console.warn('会话验证出错，清除认证状态');\n      await handleLogout(false);\n      return false;\n    } finally {\n      dispatch({\n        type: 'TOKEN_REFRESH_END'\n      });\n    }\n  };\n\n  // 初始化认证状态\n  useEffect(() => {\n    const initAuth = async () => {\n      dispatch({\n        type: 'AUTH_INIT'\n      });\n      try {\n        // 检查localStorage中是否有token\n        if (tokenManager.isAuthenticated()) {\n          console.log('发现本地存储的token，正在初始化认证状态...');\n\n          // 尝试从localStorage恢复用户信息\n          const storedUserInfo = localStorage.getItem(USER_INFO_KEY);\n          if (storedUserInfo) {\n            try {\n              const parsedUserInfo = JSON.parse(storedUserInfo);\n              console.log('从localStorage恢复用户信息:', parsedUserInfo);\n\n              // 先设置用户信息，以便快速显示UI\n              dispatch({\n                type: 'AUTH_SUCCESS',\n                payload: {\n                  user: parsedUserInfo\n                }\n              });\n\n              // 然后异步验证token有效性\n              verifySession().catch(error => {\n                console.error('会话验证失败:', error);\n              });\n            } catch (e) {\n              console.error('解析localStorage中的用户信息失败:', e);\n              dispatch({\n                type: 'AUTH_FAILURE',\n                payload: {\n                  error: '用户信息解析失败'\n                }\n              });\n            }\n          } else {\n            // 有token但没有用户信息，验证token\n            const verified = await verifySession();\n            if (!verified) {\n              dispatch({\n                type: 'AUTH_FAILURE',\n                payload: {\n                  error: '会话已过期'\n                }\n              });\n            }\n          }\n        } else {\n          console.log('未找到token，用户未登录');\n          dispatch({\n            type: 'AUTH_RESET'\n          });\n        }\n      } catch (error) {\n        console.error('初始化认证时出错:', error);\n        dispatch({\n          type: 'AUTH_FAILURE',\n          payload: {\n            error: '认证初始化失败'\n          }\n        });\n      }\n    };\n    initAuth();\n\n    // 设置定期验证会话的定时器（每15分钟）\n    const sessionCheckInterval = setInterval(() => {\n      if (tokenManager.isAuthenticated() && state.user) {\n        console.log('定期验证会话...');\n        verifySession().catch(error => {\n          console.error('定期会话验证失败:', error);\n        });\n      }\n    }, 15 * 60 * 1000);\n\n    // 监听存储事件，实现多标签页同步\n    const handleStorageChange = event => {\n      if (event.key === 'auth_token' && !event.newValue) {\n        // 其他标签页删除了token，同步登出\n        console.log('检测到其他标签页登出，同步登出状态');\n        dispatch({\n          type: 'AUTH_RESET'\n        });\n      }\n    };\n    window.addEventListener('storage', handleStorageChange);\n    return () => {\n      clearInterval(sessionCheckInterval);\n      window.removeEventListener('storage', handleStorageChange);\n    };\n  }, []);\n\n  // 处理登出逻辑\n  const handleLogout = async (callApi = true) => {\n    try {\n      if (callApi) {\n        // 调用后端登出API\n        await authService.logout().catch(error => {\n          console.warn('登出API调用失败:', error);\n        });\n      }\n    } finally {\n      // 无论API调用成功与否，都清除本地状态\n      tokenManager.removeToken();\n      localStorage.removeItem(USER_INFO_KEY);\n      localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      dispatch({\n        type: 'AUTH_RESET'\n      });\n    }\n  };\n\n  // 登录方法\n  const login = async (username, password) => {\n    dispatch({\n      type: 'AUTH_INIT'\n    });\n    try {\n      const result = await authService.login({\n        username,\n        password\n      });\n      if (result.success && result.data) {\n        // 登录成功，更新状态\n        dispatch({\n          type: 'AUTH_SUCCESS',\n          payload: {\n            user: result.data.user\n          }\n        });\n\n        // 保存用户信息到localStorage\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        message.success('登录成功！');\n        return true;\n      } else {\n        // 登录失败，显示错误\n        dispatch({\n          type: 'AUTH_FAILURE',\n          payload: {\n            error: result.message || '登录失败'\n          }\n        });\n        return false;\n      }\n    } catch (error) {\n      console.error('登录过程出错:', error);\n\n      // 网络错误特殊处理\n      if (error.message && error.message.includes('Network Error')) {\n        dispatch({\n          type: 'SET_NETWORK_ERROR',\n          payload: {\n            networkError: true\n          }\n        });\n        message.error('网络连接错误，请检查网络连接');\n      } else {\n        dispatch({\n          type: 'AUTH_FAILURE',\n          payload: {\n            error: '登录失败，请重试'\n          }\n        });\n      }\n      return false;\n    }\n  };\n\n  // 注册方法\n  const register = async (username, email, password) => {\n    dispatch({\n      type: 'AUTH_INIT'\n    });\n    try {\n      const result = await authService.register({\n        username,\n        email,\n        password\n      });\n      if (result.success && result.data) {\n        // 注册成功，更新状态\n        dispatch({\n          type: 'AUTH_SUCCESS',\n          payload: {\n            user: result.data.user\n          }\n        });\n\n        // 保存用户信息到localStorage\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        message.success('注册成功！');\n        return true;\n      } else {\n        // 注册失败，显示错误\n        dispatch({\n          type: 'AUTH_FAILURE',\n          payload: {\n            error: result.message || '注册失败'\n          }\n        });\n        return false;\n      }\n    } catch (error) {\n      console.error('注册过程出错:', error);\n\n      // 网络错误特殊处理\n      if (error.message && error.message.includes('Network Error')) {\n        dispatch({\n          type: 'SET_NETWORK_ERROR',\n          payload: {\n            networkError: true\n          }\n        });\n        message.error('网络连接错误，请检查网络连接');\n      } else {\n        dispatch({\n          type: 'AUTH_FAILURE',\n          payload: {\n            error: '注册失败，请重试'\n          }\n        });\n      }\n      return false;\n    }\n  };\n\n  // 登出方法\n  const logout = async () => {\n    await handleLogout(true);\n    message.success('已安全退出登录');\n  };\n\n  // 刷新用户信息\n  const refreshUser = async () => {\n    if (!tokenManager.isAuthenticated() || !state.user) {\n      return;\n    }\n    try {\n      const result = await authService.getProfile();\n      if (result.success && result.user) {\n        // 更新用户信息\n        dispatch({\n          type: 'AUTH_SUCCESS',\n          payload: {\n            user: result.user\n          }\n        });\n\n        // 更新localStorage中的用户信息\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n      }\n    } catch (error) {\n      console.error('刷新用户信息失败:', error);\n\n      // 网络错误不清除状态\n      if (error instanceof Error && error.message.includes('Network Error')) {\n        dispatch({\n          type: 'SET_NETWORK_ERROR',\n          payload: {\n            networkError: true\n          }\n        });\n        message.error('网络连接错误，请检查网络连接');\n      }\n    }\n  };\n\n  // 提供上下文值\n  const contextValue = {\n    ...state,\n    login,\n    register,\n    logout,\n    refreshUser,\n    verifySession\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 492,\n    columnNumber: 5\n  }, this);\n};\n\n// 使用认证上下文的Hook\n_s(AuthProvider, \"bgCdjuTOmPdSBRwTap80EFd9Y3U=\");\n_c = AuthProvider;\nexport const useAuth = () => {\n  _s2();\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n_s2(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useReducer","message","authService","tokenManager","jsxDEV","_jsxDEV","AuthContext","undefined","initialState","user","isAuthenticated","isLoading","error","lastVerified","tokenRefreshInProgress","networkError","authReducer","state","action","type","payload","Date","now","USER_INFO_KEY","AUTH_LAST_VERIFIED_KEY","AuthProvider","children","_s","dispatch","verifySession","token","getToken","console","log","tokenParts","split","length","warn","handleLogout","JSON","parse","atob","exp","e","Number","localStorage","getItem","fiveMinutes","result","verifyToken","success","setItem","stringify","toString","storedUserInfo","parsedUserInfo","Error","includes","initAuth","catch","verified","sessionCheckInterval","setInterval","handleStorageChange","event","key","newValue","window","addEventListener","clearInterval","removeEventListener","callApi","logout","removeToken","removeItem","login","username","password","data","register","email","refreshUser","getProfile","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useAuth","_s2","context","$RefreshReg$"],"sources":["E:/AICode/StockInsight/frontend/src/contexts/AuthContext.tsx"],"sourcesContent":["/**\n * 认证上下文\n * 提供全局的用户状态管理\n * 使用 useReducer 管理复杂状态，提供更健壮的认证机制\n */\n\nimport React, { createContext, useContext, useEffect, useReducer, ReactNode } from 'react';\nimport { message } from 'antd';\nimport { authService, User } from '../services/authService';\nimport { tokenManager } from '../services/api';\n\n// 认证状态类型\ninterface AuthState {\n  user: User | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  error: string | null;\n  lastVerified: number | null; // 上次验证时间戳\n  tokenRefreshInProgress: boolean; // 是否正在刷新token\n  networkError: boolean; // 是否存在网络错误\n}\n\n// 认证操作类型\ntype AuthAction =\n  | { type: 'AUTH_INIT' }\n  | { type: 'AUTH_SUCCESS'; payload: { user: User } }\n  | { type: 'AUTH_FAILURE'; payload: { error: string } }\n  | { type: 'AUTH_RESET' }\n  | { type: 'SET_LOADING'; payload: { isLoading: boolean } }\n  | { type: 'SET_NETWORK_ERROR'; payload: { networkError: boolean } }\n  | { type: 'TOKEN_REFRESH_START' }\n  | { type: 'TOKEN_REFRESH_END' };\n\n// 认证上下文类型\ninterface AuthContextType extends AuthState {\n  login: (username: string, password: string) => Promise<boolean>;\n  register: (username: string, email: string, password: string) => Promise<boolean>;\n  logout: () => Promise<void>;\n  refreshUser: () => Promise<void>;\n  verifySession: () => Promise<boolean>; // 新增：验证会话有效性\n}\n\n// 创建认证上下文\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\n// 初始状态\nconst initialState: AuthState = {\n  user: null,\n  isAuthenticated: false,\n  isLoading: true,\n  error: null,\n  lastVerified: null,\n  tokenRefreshInProgress: false,\n  networkError: false\n};\n\n// 认证状态reducer\nconst authReducer = (state: AuthState, action: AuthAction): AuthState => {\n  switch (action.type) {\n    case 'AUTH_INIT':\n      return {\n        ...state,\n        isLoading: true,\n        error: null,\n        networkError: false\n      };\n    case 'AUTH_SUCCESS':\n      return {\n        ...state,\n        user: action.payload.user,\n        isAuthenticated: true,\n        isLoading: false,\n        error: null,\n        lastVerified: Date.now(),\n        networkError: false\n      };\n    case 'AUTH_FAILURE':\n      return {\n        ...state,\n        user: null,\n        isAuthenticated: false,\n        isLoading: false,\n        error: action.payload.error,\n        lastVerified: Date.now()\n      };\n    case 'AUTH_RESET':\n      return {\n        ...initialState,\n        isLoading: false\n      };\n    case 'SET_LOADING':\n      return {\n        ...state,\n        isLoading: action.payload.isLoading\n      };\n    case 'SET_NETWORK_ERROR':\n      return {\n        ...state,\n        networkError: action.payload.networkError\n      };\n    case 'TOKEN_REFRESH_START':\n      return {\n        ...state,\n        tokenRefreshInProgress: true\n      };\n    case 'TOKEN_REFRESH_END':\n      return {\n        ...state,\n        tokenRefreshInProgress: false\n      };\n    default:\n      return state;\n  }\n};\n\n// 本地存储键\nconst USER_INFO_KEY = 'userInfo';\nconst AUTH_LAST_VERIFIED_KEY = 'auth_last_verified';\n\n// 认证提供者组件\ninterface AuthProviderProps {\n  children: ReactNode;\n}\n\nexport const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {\n  const [state, dispatch] = useReducer(authReducer, initialState);\n\n  // 验证会话有效性\n  const verifySession = async (): Promise<boolean> => {\n    // 如果没有token，直接返回false\n    const token = tokenManager.getToken();\n    if (!token) {\n      console.log('没有找到token，会话无效');\n      return false;\n    }\n\n    // 检查token格式是否有效\n    const tokenParts = token.split('.');\n    if (tokenParts.length !== 3) {\n      console.warn('token格式无效，清除认证状态');\n      await handleLogout(false);\n      return false;\n    }\n\n    // 如果正在刷新token，等待完成\n    if (state.tokenRefreshInProgress) {\n      console.log('token刷新进行中，使用当前认证状态');\n      return state.isAuthenticated;\n    }\n\n    // 检查token是否过期（通过解析JWT的payload）\n    try {\n      const payload = JSON.parse(atob(tokenParts[1]));\n      if (payload.exp && payload.exp * 1000 < Date.now()) {\n        console.warn('token已过期，清除认证状态');\n        await handleLogout(false);\n        return false;\n      }\n    } catch (e) {\n      console.warn('无法解析token payload:', e);\n      // 继续验证，让服务器决定token是否有效\n    }\n\n    // 检查上次验证时间，如果在5分钟内验证过，直接返回当前状态\n    const lastVerified = state.lastVerified || Number(localStorage.getItem(AUTH_LAST_VERIFIED_KEY)) || 0;\n    const now = Date.now();\n    const fiveMinutes = 5 * 60 * 1000;\n    \n    if (now - lastVerified < fiveMinutes && state.user) {\n      console.log('会话在5分钟内已验证，跳过验证，直接使用当前状态');\n      // 确保状态是已认证的\n      if (!state.isAuthenticated && state.user) {\n        console.log('状态不一致，更新认证状态为已认证');\n        dispatch({ type: 'AUTH_SUCCESS', payload: { user: state.user } });\n      }\n      return true;\n    }\n\n    // 开始验证token\n    console.log('开始验证token...');\n    dispatch({ type: 'TOKEN_REFRESH_START' });\n    \n    try {\n      console.log('验证会话有效性...');\n      const result = await authService.verifyToken();\n      \n      if (result.success && result.user) {\n        // 更新用户信息和验证时间\n        console.log('会话验证成功，更新用户信息');\n        dispatch({ type: 'AUTH_SUCCESS', payload: { user: result.user } });\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        return true;\n      } else if (result.networkError) {\n        // 网络错误时，如果有用户信息，保持认证状态\n        console.warn('网络错误，检查本地用户信息');\n        const storedUserInfo = localStorage.getItem(USER_INFO_KEY);\n        if (storedUserInfo) {\n          try {\n            const parsedUserInfo = JSON.parse(storedUserInfo);\n            console.log('使用本地存储的用户信息:', parsedUserInfo);\n            dispatch({ type: 'AUTH_SUCCESS', payload: { user: parsedUserInfo } });\n            dispatch({ type: 'SET_NETWORK_ERROR', payload: { networkError: true } });\n            return true;\n          } catch (e) {\n            console.error('解析本地用户信息失败:', e);\n          }\n        }\n        // 没有可用的用户信息，标记网络错误\n        dispatch({ type: 'SET_NETWORK_ERROR', payload: { networkError: true } });\n        message.error('网络连接错误，请检查网络连接');\n        return state.isAuthenticated; // 网络错误时保持当前状态\n      } else {\n        // 验证失败，清除状态\n        console.warn('会话验证失败，清除认证状态');\n        await handleLogout(false);\n        return false;\n      }\n    } catch (error) {\n      console.error('会话验证出错:', error);\n      \n      // 网络错误时不清除本地状态，但标记网络错误\n      if (error instanceof Error && error.message.includes('Network Error')) {\n        console.warn('网络错误，保持当前认证状态');\n        dispatch({ type: 'SET_NETWORK_ERROR', payload: { networkError: true } });\n        message.error('网络连接错误，请检查网络连接');\n        return state.isAuthenticated; // 网络错误时保持当前状态\n      }\n      \n      // 其他错误清除状态\n      console.warn('会话验证出错，清除认证状态');\n      await handleLogout(false);\n      return false;\n    } finally {\n      dispatch({ type: 'TOKEN_REFRESH_END' });\n    }\n  };\n\n  // 初始化认证状态\n  useEffect(() => {\n    const initAuth = async () => {\n      dispatch({ type: 'AUTH_INIT' });\n      \n      try {\n        // 检查localStorage中是否有token\n        if (tokenManager.isAuthenticated()) {\n          console.log('发现本地存储的token，正在初始化认证状态...');\n          \n          // 尝试从localStorage恢复用户信息\n          const storedUserInfo = localStorage.getItem(USER_INFO_KEY);\n          if (storedUserInfo) {\n            try {\n              const parsedUserInfo = JSON.parse(storedUserInfo);\n              console.log('从localStorage恢复用户信息:', parsedUserInfo);\n              \n              // 先设置用户信息，以便快速显示UI\n              dispatch({ \n                type: 'AUTH_SUCCESS', \n                payload: { user: parsedUserInfo } \n              });\n              \n              // 然后异步验证token有效性\n              verifySession().catch(error => {\n                console.error('会话验证失败:', error);\n              });\n            } catch (e) {\n              console.error('解析localStorage中的用户信息失败:', e);\n              dispatch({ \n                type: 'AUTH_FAILURE', \n                payload: { error: '用户信息解析失败' } \n              });\n            }\n          } else {\n            // 有token但没有用户信息，验证token\n            const verified = await verifySession();\n            if (!verified) {\n              dispatch({ \n                type: 'AUTH_FAILURE', \n                payload: { error: '会话已过期' } \n              });\n            }\n          }\n        } else {\n          console.log('未找到token，用户未登录');\n          dispatch({ type: 'AUTH_RESET' });\n        }\n      } catch (error) {\n        console.error('初始化认证时出错:', error);\n        dispatch({ \n          type: 'AUTH_FAILURE', \n          payload: { error: '认证初始化失败' } \n        });\n      }\n    };\n\n    initAuth();\n    \n    // 设置定期验证会话的定时器（每15分钟）\n    const sessionCheckInterval = setInterval(() => {\n      if (tokenManager.isAuthenticated() && state.user) {\n        console.log('定期验证会话...');\n        verifySession().catch(error => {\n          console.error('定期会话验证失败:', error);\n        });\n      }\n    }, 15 * 60 * 1000);\n    \n    // 监听存储事件，实现多标签页同步\n    const handleStorageChange = (event: StorageEvent) => {\n      if (event.key === 'auth_token' && !event.newValue) {\n        // 其他标签页删除了token，同步登出\n        console.log('检测到其他标签页登出，同步登出状态');\n        dispatch({ type: 'AUTH_RESET' });\n      }\n    };\n    \n    window.addEventListener('storage', handleStorageChange);\n    \n    return () => {\n      clearInterval(sessionCheckInterval);\n      window.removeEventListener('storage', handleStorageChange);\n    };\n  }, []);\n\n  // 处理登出逻辑\n  const handleLogout = async (callApi: boolean = true): Promise<void> => {\n    try {\n      if (callApi) {\n        // 调用后端登出API\n        await authService.logout().catch(error => {\n          console.warn('登出API调用失败:', error);\n        });\n      }\n    } finally {\n      // 无论API调用成功与否，都清除本地状态\n      tokenManager.removeToken();\n      localStorage.removeItem(USER_INFO_KEY);\n      localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      dispatch({ type: 'AUTH_RESET' });\n    }\n  };\n\n  // 登录方法\n  const login = async (username: string, password: string): Promise<boolean> => {\n    dispatch({ type: 'AUTH_INIT' });\n    \n    try {\n      const result = await authService.login({ username, password });\n      \n      if (result.success && result.data) {\n        // 登录成功，更新状态\n        dispatch({ \n          type: 'AUTH_SUCCESS', \n          payload: { user: result.data.user } \n        });\n        \n        // 保存用户信息到localStorage\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        \n        message.success('登录成功！');\n        return true;\n      } else {\n        // 登录失败，显示错误\n        dispatch({ \n          type: 'AUTH_FAILURE', \n          payload: { error: result.message || '登录失败' } \n        });\n        return false;\n      }\n    } catch (error: any) {\n      console.error('登录过程出错:', error);\n      \n      // 网络错误特殊处理\n      if (error.message && error.message.includes('Network Error')) {\n        dispatch({ \n          type: 'SET_NETWORK_ERROR', \n          payload: { networkError: true } \n        });\n        message.error('网络连接错误，请检查网络连接');\n      } else {\n        dispatch({ \n          type: 'AUTH_FAILURE', \n          payload: { error: '登录失败，请重试' } \n        });\n      }\n      \n      return false;\n    }\n  };\n\n  // 注册方法\n  const register = async (username: string, email: string, password: string): Promise<boolean> => {\n    dispatch({ type: 'AUTH_INIT' });\n    \n    try {\n      const result = await authService.register({ username, email, password });\n      \n      if (result.success && result.data) {\n        // 注册成功，更新状态\n        dispatch({ \n          type: 'AUTH_SUCCESS', \n          payload: { user: result.data.user } \n        });\n        \n        // 保存用户信息到localStorage\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        \n        message.success('注册成功！');\n        return true;\n      } else {\n        // 注册失败，显示错误\n        dispatch({ \n          type: 'AUTH_FAILURE', \n          payload: { error: result.message || '注册失败' } \n        });\n        return false;\n      }\n    } catch (error: any) {\n      console.error('注册过程出错:', error);\n      \n      // 网络错误特殊处理\n      if (error.message && error.message.includes('Network Error')) {\n        dispatch({ \n          type: 'SET_NETWORK_ERROR', \n          payload: { networkError: true } \n        });\n        message.error('网络连接错误，请检查网络连接');\n      } else {\n        dispatch({ \n          type: 'AUTH_FAILURE', \n          payload: { error: '注册失败，请重试' } \n        });\n      }\n      \n      return false;\n    }\n  };\n\n  // 登出方法\n  const logout = async (): Promise<void> => {\n    await handleLogout(true);\n    message.success('已安全退出登录');\n  };\n\n  // 刷新用户信息\n  const refreshUser = async (): Promise<void> => {\n    if (!tokenManager.isAuthenticated() || !state.user) {\n      return;\n    }\n    \n    try {\n      const result = await authService.getProfile();\n      \n      if (result.success && result.user) {\n        // 更新用户信息\n        dispatch({ \n          type: 'AUTH_SUCCESS', \n          payload: { user: result.user } \n        });\n        \n        // 更新localStorage中的用户信息\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n      }\n    } catch (error) {\n      console.error('刷新用户信息失败:', error);\n      \n      // 网络错误不清除状态\n      if (error instanceof Error && error.message.includes('Network Error')) {\n        dispatch({ \n          type: 'SET_NETWORK_ERROR', \n          payload: { networkError: true } \n        });\n        message.error('网络连接错误，请检查网络连接');\n      }\n    }\n  };\n\n  // 提供上下文值\n  const contextValue: AuthContextType = {\n    ...state,\n    login,\n    register,\n    logout,\n    refreshUser,\n    verifySession\n  };\n\n  return (\n    <AuthContext.Provider value={contextValue}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\n// 使用认证上下文的Hook\nexport const useAuth = (): AuthContextType => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}