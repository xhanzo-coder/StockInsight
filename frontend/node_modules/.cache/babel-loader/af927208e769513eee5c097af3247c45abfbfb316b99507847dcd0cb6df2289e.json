{"ast":null,"code":"/**\n * 认证服务\n * 处理用户登录、注册、令牌管理等功能\n * 增强的错误处理和重试机制\n */\n\nimport axios from 'axios';\nimport { message } from 'antd';\nimport { tokenManager } from './api';\n\n// 认证API基础URL\nconst AUTH_API_URL = 'http://localhost:5000/api/auth';\n\n// 本地存储键\nconst USER_INFO_KEY = 'userInfo';\nconst AUTH_LAST_VERIFIED_KEY = 'auth_last_verified';\n\n// 配置常量\nconst REQUEST_TIMEOUT = 15000; // 请求超时时间（毫秒）\nconst MAX_RETRY_COUNT = 2; // 最大重试次数\nconst RETRY_DELAY = 1000; // 重试延迟（毫秒）\n\n// 创建认证专用的 axios 实例\nconst authApi = axios.create({\n  baseURL: AUTH_API_URL,\n  timeout: REQUEST_TIMEOUT,\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n\n// 请求重试函数\nconst retryAuthRequest = async (config, retryCount = 0) => {\n  try {\n    return await axios(config);\n  } catch (error) {\n    // 只有在网络错误或5xx服务器错误时重试\n    const isNetworkError = !error.response;\n    const isServerError = error.response && error.response.status >= 500;\n    if ((isNetworkError || isServerError) && retryCount < MAX_RETRY_COUNT) {\n      console.log(`认证请求失败，${RETRY_DELAY / 1000}秒后重试 (${retryCount + 1}/${MAX_RETRY_COUNT})`);\n      await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));\n      return retryAuthRequest(config, retryCount + 1);\n    }\n    throw error;\n  }\n};\n\n// 添加请求拦截器 - 自动添加token到请求头\nauthApi.interceptors.request.use(config => {\n  const token = tokenManager.getToken();\n  if (token) {\n    config.headers = config.headers || {};\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n\n  // 添加请求时间戳，用于调试\n  config.headers = config.headers || {};\n  config.headers['X-Request-Time'] = new Date().toISOString();\n\n  // 记录请求信息（调试模式）\n  if (process.env.NODE_ENV === 'development') {\n    var _config$method;\n    console.log(`🔐 认证请求: ${(_config$method = config.method) === null || _config$method === void 0 ? void 0 : _config$method.toUpperCase()} ${config.url}`, {\n      headers: {\n        ...config.headers,\n        Authorization: token ? '已设置' : '未设置'\n      },\n      data: config.data,\n      params: config.params\n    });\n  }\n  return config;\n}, error => {\n  console.error('认证请求拦截器错误:', error);\n  return Promise.reject(error);\n});\n\n// 添加响应拦截器 - 处理token过期\nauthApi.interceptors.response.use(response => {\n  // 记录响应信息（调试模式）\n  if (process.env.NODE_ENV === 'development') {\n    var _response$config$meth;\n    console.log(`✅ 认证响应成功: ${(_response$config$meth = response.config.method) === null || _response$config$meth === void 0 ? void 0 : _response$config$meth.toUpperCase()} ${response.config.url}`, {\n      status: response.status,\n      data: response.data\n    });\n  }\n  return response;\n}, error => {\n  // 获取请求配置和响应\n  const {\n    config,\n    response\n  } = error;\n\n  // 记录错误信息（调试模式）\n  if (process.env.NODE_ENV === 'development') {\n    var _config$method2;\n    console.error(`❌ 认证请求失败: ${config === null || config === void 0 ? void 0 : (_config$method2 = config.method) === null || _config$method2 === void 0 ? void 0 : _config$method2.toUpperCase()} ${config === null || config === void 0 ? void 0 : config.url}`, {\n      status: response === null || response === void 0 ? void 0 : response.status,\n      data: response === null || response === void 0 ? void 0 : response.data,\n      error: error.message\n    });\n  }\n\n  // 处理401错误（未授权，通常是token过期或无效）\n  if ((response === null || response === void 0 ? void 0 : response.status) === 401) {\n    console.warn('认证请求收到401未授权响应');\n\n    // 清除认证相关数据\n    tokenManager.removeToken();\n    localStorage.removeItem(USER_INFO_KEY);\n    localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n\n    // 如果不是验证接口的请求，显示提示并重定向\n    if ((config === null || config === void 0 ? void 0 : config.url) !== '/verify') {\n      message.error('登录已过期，请重新登录');\n\n      // 使用延迟重定向，确保消息能够显示\n      setTimeout(() => {\n        // 保存当前URL，以便登录后返回\n        const currentPath = window.location.pathname;\n        if (currentPath !== '/login') {\n          sessionStorage.setItem('redirectAfterLogin', currentPath);\n        }\n        window.location.href = '/login';\n      }, 1500);\n    }\n  }\n  return Promise.reject(error);\n});\n\n// 用户数据类型\n\n// 登录请求数据\n\n// 注册请求数据\n\n// 认证响应数据\n\n// API 响应格式\n\n// 认证服务类\nexport class AuthService {\n  /**\n   * 用户注册\n   */\n  async register(userData) {\n    try {\n      // 使用重试机制发送请求\n      const response = await retryAuthRequest({\n        method: 'post',\n        url: `${AUTH_API_URL}/register`,\n        data: userData,\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      const data = response.data;\n      if (data.success && data.data) {\n        // 保存令牌 - 后端返回的是token字段\n        tokenManager.setToken(data.data.token);\n\n        // 保存用户信息和验证时间\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(data.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        message.success('注册成功！');\n        return data;\n      } else {\n        message.error(data.message || '注册失败');\n        return data;\n      }\n    } catch (error) {\n      var _error$response, _error$response2, _error$response2$data;\n      console.error('注册失败:', ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data) || error.message);\n\n      // 检查是否为网络错误\n      const isNetworkError = !error.response;\n      if (isNetworkError) {\n        const errorMessage = '网络连接错误，请检查网络连接';\n        message.error(errorMessage);\n        return {\n          success: false,\n          message: errorMessage,\n          networkError: true\n        };\n      }\n      const errorMessage = ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || '注册失败，请重试';\n      message.error(errorMessage);\n      return {\n        success: false,\n        message: errorMessage,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * 用户登录\n   */\n  async login(credentials) {\n    try {\n      console.log('开始登录请求:', credentials);\n      console.log('API URL:', AUTH_API_URL);\n\n      // 使用重试机制发送请求\n      const response = await retryAuthRequest({\n        method: 'post',\n        url: `${AUTH_API_URL}/login`,\n        data: credentials,\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      console.log('登录响应:', response.data);\n      const data = response.data;\n      if (data.success && data.data) {\n        // 保存令牌到localStorage - 后端返回的是token字段\n        tokenManager.setToken(data.data.token);\n\n        // 保存用户信息和验证时间\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(data.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n\n        // 检查是否有登录后重定向路径\n        const redirectPath = sessionStorage.getItem('redirectAfterLogin');\n        if (redirectPath) {\n          console.log(`登录成功，将重定向到: ${redirectPath}`);\n          sessionStorage.removeItem('redirectAfterLogin');\n        }\n        message.success('登录成功！');\n        return data;\n      } else {\n        console.error('登录失败:', data.message);\n        message.error(data.message || '登录失败');\n        return data;\n      }\n    } catch (error) {\n      var _error$response3, _error$response4, _error$response5, _error$response5$data;\n      console.error('登录请求异常:', error);\n      console.error('错误响应:', (_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.data);\n\n      // 检查是否为网络错误\n      const isNetworkError = !error.response;\n      if (isNetworkError) {\n        const errorMessage = '网络连接错误，请检查网络连接';\n        message.error(errorMessage);\n        return {\n          success: false,\n          message: errorMessage,\n          networkError: true\n        };\n      }\n\n      // 处理特定错误\n      if (((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status) === 401) {\n        const errorMessage = '用户名或密码错误';\n        message.error(errorMessage);\n        return {\n          success: false,\n          message: errorMessage,\n          error: error.message\n        };\n      }\n      const errorMessage = ((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : (_error$response5$data = _error$response5.data) === null || _error$response5$data === void 0 ? void 0 : _error$response5$data.message) || '登录失败，请重试';\n      message.error(errorMessage);\n      return {\n        success: false,\n        message: errorMessage,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * 验证令牌\n   */\n  async verifyToken() {\n    try {\n      const token = tokenManager.getToken();\n      if (!token) {\n        console.log('没有找到token，无法验证');\n        return {\n          success: false\n        };\n      }\n      console.log('开始验证token...', token.substring(0, 15) + '...');\n      console.log('Token格式检查:', token.split('.').length === 3 ? '有效' : '无效');\n\n      // 直接检查token是否有效\n      if (!tokenManager.isAuthenticated()) {\n        console.warn('本地token验证失败，可能已过期');\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n        return {\n          success: false\n        };\n      }\n\n      // 使用重试机制发送请求\n      console.log(`发送验证请求到: ${AUTH_API_URL}/verify`);\n      const response = await retryAuthRequest({\n        method: 'get',\n        url: `${AUTH_API_URL}/verify`,\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n\n      // 请求拦截器会自动添加Authorization头\n      const data = response.data;\n      console.log('验证响应:', data);\n      if (data.success && data.data && data.data.user) {\n        console.log('Token验证成功，用户信息:', data.data.user);\n\n        // 更新验证时间\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        return {\n          success: true,\n          user: data.data.user\n        };\n      } else {\n        console.log('Token验证失败，服务器返回:', data);\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n        return {\n          success: false\n        };\n      }\n    } catch (error) {\n      var _error$response6, _error$response7;\n      console.error('令牌验证失败:', error);\n      console.error('错误状态码:', (_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : _error$response6.status);\n      console.error('错误详情:', (_error$response7 = error.response) === null || _error$response7 === void 0 ? void 0 : _error$response7.data);\n\n      // 检查是否为网络错误\n      const isNetworkError = !error.response;\n      if (isNetworkError) {\n        console.warn('验证token: 网络错误，保持当前状态');\n        return {\n          success: false,\n          networkError: true\n        };\n      }\n\n      // 清除无效的token（除非是网络错误）\n      if (!isNetworkError) {\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      }\n      return {\n        success: false\n      };\n    }\n  }\n\n  /**\n   * 获取用户资料\n   */\n  async getProfile() {\n    try {\n      const token = tokenManager.getToken();\n      if (!token) {\n        return {\n          success: false\n        };\n      }\n\n      // 使用重试机制发送请求\n      const response = await retryAuthRequest({\n        method: 'get',\n        url: `${AUTH_API_URL}/profile`,\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n\n      // 请求拦截器会自动添加Authorization头\n      const data = response.data;\n      if (data.success && data.data && data.data.user) {\n        // 更新用户信息和验证时间\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(data.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        return {\n          success: true,\n          user: data.data.user\n        };\n      } else {\n        return {\n          success: false\n        };\n      }\n    } catch (error) {\n      var _error$response8;\n      console.error('获取用户资料失败:', error);\n\n      // 检查是否为网络错误\n      const isNetworkError = !error.response;\n      if (isNetworkError) {\n        return {\n          success: false,\n          networkError: true\n        };\n      }\n\n      // 如果是401错误，清除认证状态\n      if (((_error$response8 = error.response) === null || _error$response8 === void 0 ? void 0 : _error$response8.status) === 401) {\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      }\n      return {\n        success: false\n      };\n    }\n  }\n\n  /**\n   * 用户登出\n   */\n  async logout() {\n    try {\n      const token = tokenManager.getToken();\n      if (token) {\n        try {\n          // 可选：调用后端登出接口\n          await authApi.post('/logout');\n          // 注意：由于添加了请求拦截器，这里不需要手动添加Authorization头\n          console.log('成功调用登出API');\n        } catch (error) {\n          console.warn('登出API调用失败，但会继续清除本地状态:', error);\n        }\n      }\n\n      // 无论如何都要清除本地令牌和用户信息\n      tokenManager.removeToken();\n      localStorage.removeItem(USER_INFO_KEY);\n      localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      return {\n        success: true,\n        message: '已安全退出登录'\n      };\n    } catch (error) {\n      console.error('登出过程出错:', error);\n\n      // 即使出错，也要尝试清除本地状态\n      try {\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      } catch (e) {\n        console.error('清除本地状态失败:', e);\n      }\n      return {\n        success: false,\n        message: '登出过程出错，但已清除本地登录状态'\n      };\n    }\n  }\n\n  /**\n   * 检查是否已认证\n   */\n  isAuthenticated() {\n    return tokenManager.isAuthenticated();\n  }\n\n  /**\n   * 检查认证状态（本地检查，不发送网络请求）\n   */\n  checkAuthStatus() {\n    const isAuthenticated = this.isAuthenticated();\n    let user = null;\n\n    // 如果有token，尝试从localStorage获取用户信息\n    if (isAuthenticated) {\n      try {\n        const userInfo = localStorage.getItem(USER_INFO_KEY);\n        if (userInfo) {\n          user = JSON.parse(userInfo);\n        }\n      } catch (e) {\n        console.error('解析用户信息失败:', e);\n      }\n    }\n    return {\n      isAuthenticated,\n      user\n    };\n  }\n}\nexport const authService = new AuthService();","map":{"version":3,"names":["axios","message","tokenManager","AUTH_API_URL","USER_INFO_KEY","AUTH_LAST_VERIFIED_KEY","REQUEST_TIMEOUT","MAX_RETRY_COUNT","RETRY_DELAY","authApi","create","baseURL","timeout","headers","retryAuthRequest","config","retryCount","error","isNetworkError","response","isServerError","status","console","log","Promise","resolve","setTimeout","interceptors","request","use","token","getToken","Authorization","Date","toISOString","process","env","NODE_ENV","_config$method","method","toUpperCase","url","data","params","reject","_response$config$meth","_config$method2","warn","removeToken","localStorage","removeItem","currentPath","window","location","pathname","sessionStorage","setItem","href","AuthService","register","userData","success","setToken","JSON","stringify","user","now","toString","_error$response","_error$response2","_error$response2$data","errorMessage","networkError","login","credentials","redirectPath","getItem","_error$response3","_error$response4","_error$response5","_error$response5$data","verifyToken","substring","split","length","isAuthenticated","_error$response6","_error$response7","getProfile","_error$response8","logout","post","e","checkAuthStatus","userInfo","parse","authService"],"sources":["E:/AICode/StockInsight/frontend/src/services/authService.ts"],"sourcesContent":["/**\n * 认证服务\n * 处理用户登录、注册、令牌管理等功能\n * 增强的错误处理和重试机制\n */\n\nimport axios, { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';\nimport { message } from 'antd';\nimport { tokenManager } from './api';\n\n// 认证API基础URL\nconst AUTH_API_URL = 'http://localhost:5000/api/auth';\n\n// 本地存储键\nconst USER_INFO_KEY = 'userInfo';\nconst AUTH_LAST_VERIFIED_KEY = 'auth_last_verified';\n\n// 配置常量\nconst REQUEST_TIMEOUT = 15000; // 请求超时时间（毫秒）\nconst MAX_RETRY_COUNT = 2; // 最大重试次数\nconst RETRY_DELAY = 1000; // 重试延迟（毫秒）\n\n// 创建认证专用的 axios 实例\nconst authApi = axios.create({\n  baseURL: AUTH_API_URL,\n  timeout: REQUEST_TIMEOUT,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\n// 请求重试函数\nconst retryAuthRequest = async (config: AxiosRequestConfig, retryCount: number = 0): Promise<AxiosResponse> => {\n  try {\n    return await axios(config);\n  } catch (error: any) {\n    // 只有在网络错误或5xx服务器错误时重试\n    const isNetworkError = !error.response;\n    const isServerError = error.response && error.response.status >= 500;\n    \n    if ((isNetworkError || isServerError) && retryCount < MAX_RETRY_COUNT) {\n      console.log(`认证请求失败，${RETRY_DELAY/1000}秒后重试 (${retryCount + 1}/${MAX_RETRY_COUNT})`);\n      await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));\n      return retryAuthRequest(config, retryCount + 1);\n    }\n    \n    throw error;\n  }\n};\n\n// 添加请求拦截器 - 自动添加token到请求头\nauthApi.interceptors.request.use(\n  (config) => {\n    const token = tokenManager.getToken();\n    if (token) {\n      config.headers = config.headers || {};\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n    \n    // 添加请求时间戳，用于调试\n    config.headers = config.headers || {};\n    config.headers['X-Request-Time'] = new Date().toISOString();\n    \n    // 记录请求信息（调试模式）\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`🔐 认证请求: ${config.method?.toUpperCase()} ${config.url}`, {\n        headers: { ...config.headers, Authorization: token ? '已设置' : '未设置' },\n        data: config.data,\n        params: config.params\n      });\n    }\n    \n    return config;\n  },\n  (error) => {\n    console.error('认证请求拦截器错误:', error);\n    return Promise.reject(error);\n  }\n);\n\n// 添加响应拦截器 - 处理token过期\nauthApi.interceptors.response.use(\n  (response) => {\n    // 记录响应信息（调试模式）\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`✅ 认证响应成功: ${response.config.method?.toUpperCase()} ${response.config.url}`, {\n        status: response.status,\n        data: response.data\n      });\n    }\n    \n    return response;\n  },\n  (error: AxiosError) => {\n    // 获取请求配置和响应\n    const { config, response } = error;\n    \n    // 记录错误信息（调试模式）\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`❌ 认证请求失败: ${config?.method?.toUpperCase()} ${config?.url}`, {\n        status: response?.status,\n        data: response?.data,\n        error: error.message\n      });\n    }\n    \n    // 处理401错误（未授权，通常是token过期或无效）\n    if (response?.status === 401) {\n      console.warn('认证请求收到401未授权响应');\n      \n      // 清除认证相关数据\n      tokenManager.removeToken();\n      localStorage.removeItem(USER_INFO_KEY);\n      localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      \n      // 如果不是验证接口的请求，显示提示并重定向\n      if (config?.url !== '/verify') {\n        message.error('登录已过期，请重新登录');\n        \n        // 使用延迟重定向，确保消息能够显示\n        setTimeout(() => {\n          // 保存当前URL，以便登录后返回\n          const currentPath = window.location.pathname;\n          if (currentPath !== '/login') {\n            sessionStorage.setItem('redirectAfterLogin', currentPath);\n          }\n          \n          window.location.href = '/login';\n        }, 1500);\n      }\n    }\n    \n    return Promise.reject(error);\n  }\n);\n\n// 用户数据类型\nexport interface User {\n  id: number;\n  username: string;\n  email: string;\n  created_at: string;\n  last_login?: string;\n}\n\n// 登录请求数据\nexport interface LoginRequest {\n  username: string;\n  password: string;\n}\n\n// 注册请求数据\nexport interface RegisterRequest {\n  username: string;\n  email: string;\n  password: string;\n}\n\n// 认证响应数据\nexport interface AuthResponse {\n  user: User;\n  token: string; // 后端返回的是token字段，而不是access_token\n}\n\n// API 响应格式\nexport interface ApiResponse<T> {\n  success: boolean;\n  data?: T;\n  message?: string;\n  error?: string;\n  networkError?: boolean;\n}\n\n// 认证服务类\nexport class AuthService {\n\n  /**\n   * 用户注册\n   */\n  async register(userData: RegisterRequest): Promise<ApiResponse<AuthResponse>> {\n    try {\n      // 使用重试机制发送请求\n      const response = await retryAuthRequest({\n        method: 'post',\n        url: `${AUTH_API_URL}/register`,\n        data: userData,\n        headers: { 'Content-Type': 'application/json' }\n      });\n      \n      const data = response.data;\n\n      if (data.success && data.data) {\n        // 保存令牌 - 后端返回的是token字段\n        tokenManager.setToken(data.data.token);\n        \n        // 保存用户信息和验证时间\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(data.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        \n        message.success('注册成功！');\n        return data;\n      } else {\n        message.error(data.message || '注册失败');\n        return data;\n      }\n    } catch (error: any) {\n      console.error('注册失败:', error.response?.data || error.message);\n      \n      // 检查是否为网络错误\n      const isNetworkError = !error.response;\n      if (isNetworkError) {\n        const errorMessage = '网络连接错误，请检查网络连接';\n        message.error(errorMessage);\n        return {\n          success: false,\n          message: errorMessage,\n          networkError: true\n        };\n      }\n      \n      const errorMessage = error.response?.data?.message || '注册失败，请重试';\n      message.error(errorMessage);\n      return {\n        success: false,\n        message: errorMessage,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * 用户登录\n   */\n  async login(credentials: LoginRequest): Promise<ApiResponse<AuthResponse>> {\n    try {\n      console.log('开始登录请求:', credentials);\n      console.log('API URL:', AUTH_API_URL);\n      \n      // 使用重试机制发送请求\n      const response = await retryAuthRequest({\n        method: 'post',\n        url: `${AUTH_API_URL}/login`,\n        data: credentials,\n        headers: { 'Content-Type': 'application/json' }\n      });\n      \n      console.log('登录响应:', response.data);\n      \n      const data = response.data;\n\n      if (data.success && data.data) {\n        // 保存令牌到localStorage - 后端返回的是token字段\n        tokenManager.setToken(data.data.token);\n        \n        // 保存用户信息和验证时间\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(data.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        \n        // 检查是否有登录后重定向路径\n        const redirectPath = sessionStorage.getItem('redirectAfterLogin');\n        if (redirectPath) {\n          console.log(`登录成功，将重定向到: ${redirectPath}`);\n          sessionStorage.removeItem('redirectAfterLogin');\n        }\n        \n        message.success('登录成功！');\n        return data;\n      } else {\n        console.error('登录失败:', data.message);\n        message.error(data.message || '登录失败');\n        return data;\n      }\n    } catch (error: any) {\n      console.error('登录请求异常:', error);\n      console.error('错误响应:', error.response?.data);\n      \n      // 检查是否为网络错误\n      const isNetworkError = !error.response;\n      if (isNetworkError) {\n        const errorMessage = '网络连接错误，请检查网络连接';\n        message.error(errorMessage);\n        return {\n          success: false,\n          message: errorMessage,\n          networkError: true\n        };\n      }\n      \n      // 处理特定错误\n      if (error.response?.status === 401) {\n        const errorMessage = '用户名或密码错误';\n        message.error(errorMessage);\n        return {\n          success: false,\n          message: errorMessage,\n          error: error.message\n        };\n      }\n      \n      const errorMessage = error.response?.data?.message || '登录失败，请重试';\n      message.error(errorMessage);\n      return {\n        success: false,\n        message: errorMessage,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * 验证令牌\n   */\n  async verifyToken(): Promise<{ success: boolean; user?: User; networkError?: boolean }> {\n    try {\n      const token = tokenManager.getToken();\n      if (!token) {\n        console.log('没有找到token，无法验证');\n        return { success: false };\n      }\n\n      console.log('开始验证token...', token.substring(0, 15) + '...');\n      console.log('Token格式检查:', token.split('.').length === 3 ? '有效' : '无效');\n      \n      // 直接检查token是否有效\n      if (!tokenManager.isAuthenticated()) {\n        console.warn('本地token验证失败，可能已过期');\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n        return { success: false };\n      }\n      \n      // 使用重试机制发送请求\n      console.log(`发送验证请求到: ${AUTH_API_URL}/verify`);\n      const response = await retryAuthRequest({\n        method: 'get',\n        url: `${AUTH_API_URL}/verify`,\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n      \n      // 请求拦截器会自动添加Authorization头\n      const data = response.data;\n      console.log('验证响应:', data);\n      \n      if (data.success && data.data && data.data.user) {\n        console.log('Token验证成功，用户信息:', data.data.user);\n        \n        // 更新验证时间\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        \n        return { success: true, user: data.data.user };\n      } else {\n        console.log('Token验证失败，服务器返回:', data);\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n        return { success: false };\n      }\n    } catch (error: any) {\n      console.error('令牌验证失败:', error);\n      console.error('错误状态码:', error.response?.status);\n      console.error('错误详情:', error.response?.data);\n      \n      // 检查是否为网络错误\n      const isNetworkError = !error.response;\n      if (isNetworkError) {\n        console.warn('验证token: 网络错误，保持当前状态');\n        return {\n          success: false,\n          networkError: true\n        };\n      }\n      \n      // 清除无效的token（除非是网络错误）\n      if (!isNetworkError) {\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      }\n      \n      return { success: false };\n    }\n  }\n\n  /**\n   * 获取用户资料\n   */\n  async getProfile(): Promise<{ success: boolean; user?: User; networkError?: boolean }> {\n    try {\n      const token = tokenManager.getToken();\n      if (!token) {\n        return { success: false };\n      }\n\n      // 使用重试机制发送请求\n      const response = await retryAuthRequest({\n        method: 'get',\n        url: `${AUTH_API_URL}/profile`,\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n      \n      // 请求拦截器会自动添加Authorization头\n      const data = response.data;\n      \n      if (data.success && data.data && data.data.user) {\n        // 更新用户信息和验证时间\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(data.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        \n        return { success: true, user: data.data.user };\n      } else {\n        return { success: false };\n      }\n    } catch (error: any) {\n      console.error('获取用户资料失败:', error);\n      \n      // 检查是否为网络错误\n      const isNetworkError = !error.response;\n      if (isNetworkError) {\n        return {\n          success: false,\n          networkError: true\n        };\n      }\n      \n      // 如果是401错误，清除认证状态\n      if (error.response?.status === 401) {\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      }\n      \n      return { success: false };\n    }\n  }\n\n  /**\n   * 用户登出\n   */\n  async logout(): Promise<{ success: boolean; message?: string }> {\n    try {\n      const token = tokenManager.getToken();\n      if (token) {\n        try {\n          // 可选：调用后端登出接口\n          await authApi.post('/logout');\n          // 注意：由于添加了请求拦截器，这里不需要手动添加Authorization头\n          console.log('成功调用登出API');\n        } catch (error) {\n          console.warn('登出API调用失败，但会继续清除本地状态:', error);\n        }\n      }\n      \n      // 无论如何都要清除本地令牌和用户信息\n      tokenManager.removeToken();\n      localStorage.removeItem(USER_INFO_KEY);\n      localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      \n      return { success: true, message: '已安全退出登录' };\n    } catch (error: any) {\n      console.error('登出过程出错:', error);\n      \n      // 即使出错，也要尝试清除本地状态\n      try {\n        tokenManager.removeToken();\n        localStorage.removeItem(USER_INFO_KEY);\n        localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      } catch (e) {\n        console.error('清除本地状态失败:', e);\n      }\n      \n      return {\n        success: false,\n        message: '登出过程出错，但已清除本地登录状态'\n      };\n    }\n  }\n\n  /**\n   * 检查是否已认证\n   */\n  isAuthenticated(): boolean {\n    return tokenManager.isAuthenticated();\n  }\n  \n  /**\n   * 检查认证状态（本地检查，不发送网络请求）\n   */\n  checkAuthStatus(): { isAuthenticated: boolean; user: User | null } {\n    const isAuthenticated = this.isAuthenticated();\n    let user: User | null = null;\n    \n    // 如果有token，尝试从localStorage获取用户信息\n    if (isAuthenticated) {\n      try {\n        const userInfo = localStorage.getItem(USER_INFO_KEY);\n        if (userInfo) {\n          user = JSON.parse(userInfo);\n        }\n      } catch (e) {\n        console.error('解析用户信息失败:', e);\n      }\n    }\n    \n    return { isAuthenticated, user };\n  }\n}\n\nexport const authService = new AuthService();"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,OAAOA,KAAK,MAAyD,OAAO;AAC5E,SAASC,OAAO,QAAQ,MAAM;AAC9B,SAASC,YAAY,QAAQ,OAAO;;AAEpC;AACA,MAAMC,YAAY,GAAG,gCAAgC;;AAErD;AACA,MAAMC,aAAa,GAAG,UAAU;AAChC,MAAMC,sBAAsB,GAAG,oBAAoB;;AAEnD;AACA,MAAMC,eAAe,GAAG,KAAK,CAAC,CAAC;AAC/B,MAAMC,eAAe,GAAG,CAAC,CAAC,CAAC;AAC3B,MAAMC,WAAW,GAAG,IAAI,CAAC,CAAC;;AAE1B;AACA,MAAMC,OAAO,GAAGT,KAAK,CAACU,MAAM,CAAC;EAC3BC,OAAO,EAAER,YAAY;EACrBS,OAAO,EAAEN,eAAe;EACxBO,OAAO,EAAE;IACP,cAAc,EAAE;EAClB;AACF,CAAC,CAAC;;AAEF;AACA,MAAMC,gBAAgB,GAAG,MAAAA,CAAOC,MAA0B,EAAEC,UAAkB,GAAG,CAAC,KAA6B;EAC7G,IAAI;IACF,OAAO,MAAMhB,KAAK,CAACe,MAAM,CAAC;EAC5B,CAAC,CAAC,OAAOE,KAAU,EAAE;IACnB;IACA,MAAMC,cAAc,GAAG,CAACD,KAAK,CAACE,QAAQ;IACtC,MAAMC,aAAa,GAAGH,KAAK,CAACE,QAAQ,IAAIF,KAAK,CAACE,QAAQ,CAACE,MAAM,IAAI,GAAG;IAEpE,IAAI,CAACH,cAAc,IAAIE,aAAa,KAAKJ,UAAU,GAAGT,eAAe,EAAE;MACrEe,OAAO,CAACC,GAAG,CAAC,UAAUf,WAAW,GAAC,IAAI,SAASQ,UAAU,GAAG,CAAC,IAAIT,eAAe,GAAG,CAAC;MACpF,MAAM,IAAIiB,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAEjB,WAAW,CAAC,CAAC;MAC9D,OAAOM,gBAAgB,CAACC,MAAM,EAAEC,UAAU,GAAG,CAAC,CAAC;IACjD;IAEA,MAAMC,KAAK;EACb;AACF,CAAC;;AAED;AACAR,OAAO,CAACkB,YAAY,CAACC,OAAO,CAACC,GAAG,CAC7Bd,MAAM,IAAK;EACV,MAAMe,KAAK,GAAG5B,YAAY,CAAC6B,QAAQ,CAAC,CAAC;EACrC,IAAID,KAAK,EAAE;IACTf,MAAM,CAACF,OAAO,GAAGE,MAAM,CAACF,OAAO,IAAI,CAAC,CAAC;IACrCE,MAAM,CAACF,OAAO,CAACmB,aAAa,GAAG,UAAUF,KAAK,EAAE;EAClD;;EAEA;EACAf,MAAM,CAACF,OAAO,GAAGE,MAAM,CAACF,OAAO,IAAI,CAAC,CAAC;EACrCE,MAAM,CAACF,OAAO,CAAC,gBAAgB,CAAC,GAAG,IAAIoB,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;;EAE3D;EACA,IAAIC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,EAAE;IAAA,IAAAC,cAAA;IAC1ChB,OAAO,CAACC,GAAG,CAAC,aAAAe,cAAA,GAAYvB,MAAM,CAACwB,MAAM,cAAAD,cAAA,uBAAbA,cAAA,CAAeE,WAAW,CAAC,CAAC,IAAIzB,MAAM,CAAC0B,GAAG,EAAE,EAAE;MACpE5B,OAAO,EAAE;QAAE,GAAGE,MAAM,CAACF,OAAO;QAAEmB,aAAa,EAAEF,KAAK,GAAG,KAAK,GAAG;MAAM,CAAC;MACpEY,IAAI,EAAE3B,MAAM,CAAC2B,IAAI;MACjBC,MAAM,EAAE5B,MAAM,CAAC4B;IACjB,CAAC,CAAC;EACJ;EAEA,OAAO5B,MAAM;AACf,CAAC,EACAE,KAAK,IAAK;EACTK,OAAO,CAACL,KAAK,CAAC,YAAY,EAAEA,KAAK,CAAC;EAClC,OAAOO,OAAO,CAACoB,MAAM,CAAC3B,KAAK,CAAC;AAC9B,CACF,CAAC;;AAED;AACAR,OAAO,CAACkB,YAAY,CAACR,QAAQ,CAACU,GAAG,CAC9BV,QAAQ,IAAK;EACZ;EACA,IAAIgB,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,EAAE;IAAA,IAAAQ,qBAAA;IAC1CvB,OAAO,CAACC,GAAG,CAAC,cAAAsB,qBAAA,GAAa1B,QAAQ,CAACJ,MAAM,CAACwB,MAAM,cAAAM,qBAAA,uBAAtBA,qBAAA,CAAwBL,WAAW,CAAC,CAAC,IAAIrB,QAAQ,CAACJ,MAAM,CAAC0B,GAAG,EAAE,EAAE;MACvFpB,MAAM,EAAEF,QAAQ,CAACE,MAAM;MACvBqB,IAAI,EAAEvB,QAAQ,CAACuB;IACjB,CAAC,CAAC;EACJ;EAEA,OAAOvB,QAAQ;AACjB,CAAC,EACAF,KAAiB,IAAK;EACrB;EACA,MAAM;IAAEF,MAAM;IAAEI;EAAS,CAAC,GAAGF,KAAK;;EAElC;EACA,IAAIkB,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,EAAE;IAAA,IAAAS,eAAA;IAC1CxB,OAAO,CAACL,KAAK,CAAC,aAAaF,MAAM,aAANA,MAAM,wBAAA+B,eAAA,GAAN/B,MAAM,CAAEwB,MAAM,cAAAO,eAAA,uBAAdA,eAAA,CAAgBN,WAAW,CAAC,CAAC,IAAIzB,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAE0B,GAAG,EAAE,EAAE;MACzEpB,MAAM,EAAEF,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEE,MAAM;MACxBqB,IAAI,EAAEvB,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEuB,IAAI;MACpBzB,KAAK,EAAEA,KAAK,CAAChB;IACf,CAAC,CAAC;EACJ;;EAEA;EACA,IAAI,CAAAkB,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEE,MAAM,MAAK,GAAG,EAAE;IAC5BC,OAAO,CAACyB,IAAI,CAAC,gBAAgB,CAAC;;IAE9B;IACA7C,YAAY,CAAC8C,WAAW,CAAC,CAAC;IAC1BC,YAAY,CAACC,UAAU,CAAC9C,aAAa,CAAC;IACtC6C,YAAY,CAACC,UAAU,CAAC7C,sBAAsB,CAAC;;IAE/C;IACA,IAAI,CAAAU,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAE0B,GAAG,MAAK,SAAS,EAAE;MAC7BxC,OAAO,CAACgB,KAAK,CAAC,aAAa,CAAC;;MAE5B;MACAS,UAAU,CAAC,MAAM;QACf;QACA,MAAMyB,WAAW,GAAGC,MAAM,CAACC,QAAQ,CAACC,QAAQ;QAC5C,IAAIH,WAAW,KAAK,QAAQ,EAAE;UAC5BI,cAAc,CAACC,OAAO,CAAC,oBAAoB,EAAEL,WAAW,CAAC;QAC3D;QAEAC,MAAM,CAACC,QAAQ,CAACI,IAAI,GAAG,QAAQ;MACjC,CAAC,EAAE,IAAI,CAAC;IACV;EACF;EAEA,OAAOjC,OAAO,CAACoB,MAAM,CAAC3B,KAAK,CAAC;AAC9B,CACF,CAAC;;AAED;;AASA;;AAMA;;AAOA;;AAMA;;AASA;AACA,OAAO,MAAMyC,WAAW,CAAC;EAEvB;AACF;AACA;EACE,MAAMC,QAAQA,CAACC,QAAyB,EAAsC;IAC5E,IAAI;MACF;MACA,MAAMzC,QAAQ,GAAG,MAAML,gBAAgB,CAAC;QACtCyB,MAAM,EAAE,MAAM;QACdE,GAAG,EAAE,GAAGtC,YAAY,WAAW;QAC/BuC,IAAI,EAAEkB,QAAQ;QACd/C,OAAO,EAAE;UAAE,cAAc,EAAE;QAAmB;MAChD,CAAC,CAAC;MAEF,MAAM6B,IAAI,GAAGvB,QAAQ,CAACuB,IAAI;MAE1B,IAAIA,IAAI,CAACmB,OAAO,IAAInB,IAAI,CAACA,IAAI,EAAE;QAC7B;QACAxC,YAAY,CAAC4D,QAAQ,CAACpB,IAAI,CAACA,IAAI,CAACZ,KAAK,CAAC;;QAEtC;QACAmB,YAAY,CAACO,OAAO,CAACpD,aAAa,EAAE2D,IAAI,CAACC,SAAS,CAACtB,IAAI,CAACA,IAAI,CAACuB,IAAI,CAAC,CAAC;QACnEhB,YAAY,CAACO,OAAO,CAACnD,sBAAsB,EAAE4B,IAAI,CAACiC,GAAG,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,CAAC;QAEnElE,OAAO,CAAC4D,OAAO,CAAC,OAAO,CAAC;QACxB,OAAOnB,IAAI;MACb,CAAC,MAAM;QACLzC,OAAO,CAACgB,KAAK,CAACyB,IAAI,CAACzC,OAAO,IAAI,MAAM,CAAC;QACrC,OAAOyC,IAAI;MACb;IACF,CAAC,CAAC,OAAOzB,KAAU,EAAE;MAAA,IAAAmD,eAAA,EAAAC,gBAAA,EAAAC,qBAAA;MACnBhD,OAAO,CAACL,KAAK,CAAC,OAAO,EAAE,EAAAmD,eAAA,GAAAnD,KAAK,CAACE,QAAQ,cAAAiD,eAAA,uBAAdA,eAAA,CAAgB1B,IAAI,KAAIzB,KAAK,CAAChB,OAAO,CAAC;;MAE7D;MACA,MAAMiB,cAAc,GAAG,CAACD,KAAK,CAACE,QAAQ;MACtC,IAAID,cAAc,EAAE;QAClB,MAAMqD,YAAY,GAAG,gBAAgB;QACrCtE,OAAO,CAACgB,KAAK,CAACsD,YAAY,CAAC;QAC3B,OAAO;UACLV,OAAO,EAAE,KAAK;UACd5D,OAAO,EAAEsE,YAAY;UACrBC,YAAY,EAAE;QAChB,CAAC;MACH;MAEA,MAAMD,YAAY,GAAG,EAAAF,gBAAA,GAAApD,KAAK,CAACE,QAAQ,cAAAkD,gBAAA,wBAAAC,qBAAA,GAAdD,gBAAA,CAAgB3B,IAAI,cAAA4B,qBAAA,uBAApBA,qBAAA,CAAsBrE,OAAO,KAAI,UAAU;MAChEA,OAAO,CAACgB,KAAK,CAACsD,YAAY,CAAC;MAC3B,OAAO;QACLV,OAAO,EAAE,KAAK;QACd5D,OAAO,EAAEsE,YAAY;QACrBtD,KAAK,EAAEA,KAAK,CAAChB;MACf,CAAC;IACH;EACF;;EAEA;AACF;AACA;EACE,MAAMwE,KAAKA,CAACC,WAAyB,EAAsC;IACzE,IAAI;MACFpD,OAAO,CAACC,GAAG,CAAC,SAAS,EAAEmD,WAAW,CAAC;MACnCpD,OAAO,CAACC,GAAG,CAAC,UAAU,EAAEpB,YAAY,CAAC;;MAErC;MACA,MAAMgB,QAAQ,GAAG,MAAML,gBAAgB,CAAC;QACtCyB,MAAM,EAAE,MAAM;QACdE,GAAG,EAAE,GAAGtC,YAAY,QAAQ;QAC5BuC,IAAI,EAAEgC,WAAW;QACjB7D,OAAO,EAAE;UAAE,cAAc,EAAE;QAAmB;MAChD,CAAC,CAAC;MAEFS,OAAO,CAACC,GAAG,CAAC,OAAO,EAAEJ,QAAQ,CAACuB,IAAI,CAAC;MAEnC,MAAMA,IAAI,GAAGvB,QAAQ,CAACuB,IAAI;MAE1B,IAAIA,IAAI,CAACmB,OAAO,IAAInB,IAAI,CAACA,IAAI,EAAE;QAC7B;QACAxC,YAAY,CAAC4D,QAAQ,CAACpB,IAAI,CAACA,IAAI,CAACZ,KAAK,CAAC;;QAEtC;QACAmB,YAAY,CAACO,OAAO,CAACpD,aAAa,EAAE2D,IAAI,CAACC,SAAS,CAACtB,IAAI,CAACA,IAAI,CAACuB,IAAI,CAAC,CAAC;QACnEhB,YAAY,CAACO,OAAO,CAACnD,sBAAsB,EAAE4B,IAAI,CAACiC,GAAG,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,CAAC;;QAEnE;QACA,MAAMQ,YAAY,GAAGpB,cAAc,CAACqB,OAAO,CAAC,oBAAoB,CAAC;QACjE,IAAID,YAAY,EAAE;UAChBrD,OAAO,CAACC,GAAG,CAAC,eAAeoD,YAAY,EAAE,CAAC;UAC1CpB,cAAc,CAACL,UAAU,CAAC,oBAAoB,CAAC;QACjD;QAEAjD,OAAO,CAAC4D,OAAO,CAAC,OAAO,CAAC;QACxB,OAAOnB,IAAI;MACb,CAAC,MAAM;QACLpB,OAAO,CAACL,KAAK,CAAC,OAAO,EAAEyB,IAAI,CAACzC,OAAO,CAAC;QACpCA,OAAO,CAACgB,KAAK,CAACyB,IAAI,CAACzC,OAAO,IAAI,MAAM,CAAC;QACrC,OAAOyC,IAAI;MACb;IACF,CAAC,CAAC,OAAOzB,KAAU,EAAE;MAAA,IAAA4D,gBAAA,EAAAC,gBAAA,EAAAC,gBAAA,EAAAC,qBAAA;MACnB1D,OAAO,CAACL,KAAK,CAAC,SAAS,EAAEA,KAAK,CAAC;MAC/BK,OAAO,CAACL,KAAK,CAAC,OAAO,GAAA4D,gBAAA,GAAE5D,KAAK,CAACE,QAAQ,cAAA0D,gBAAA,uBAAdA,gBAAA,CAAgBnC,IAAI,CAAC;;MAE5C;MACA,MAAMxB,cAAc,GAAG,CAACD,KAAK,CAACE,QAAQ;MACtC,IAAID,cAAc,EAAE;QAClB,MAAMqD,YAAY,GAAG,gBAAgB;QACrCtE,OAAO,CAACgB,KAAK,CAACsD,YAAY,CAAC;QAC3B,OAAO;UACLV,OAAO,EAAE,KAAK;UACd5D,OAAO,EAAEsE,YAAY;UACrBC,YAAY,EAAE;QAChB,CAAC;MACH;;MAEA;MACA,IAAI,EAAAM,gBAAA,GAAA7D,KAAK,CAACE,QAAQ,cAAA2D,gBAAA,uBAAdA,gBAAA,CAAgBzD,MAAM,MAAK,GAAG,EAAE;QAClC,MAAMkD,YAAY,GAAG,UAAU;QAC/BtE,OAAO,CAACgB,KAAK,CAACsD,YAAY,CAAC;QAC3B,OAAO;UACLV,OAAO,EAAE,KAAK;UACd5D,OAAO,EAAEsE,YAAY;UACrBtD,KAAK,EAAEA,KAAK,CAAChB;QACf,CAAC;MACH;MAEA,MAAMsE,YAAY,GAAG,EAAAQ,gBAAA,GAAA9D,KAAK,CAACE,QAAQ,cAAA4D,gBAAA,wBAAAC,qBAAA,GAAdD,gBAAA,CAAgBrC,IAAI,cAAAsC,qBAAA,uBAApBA,qBAAA,CAAsB/E,OAAO,KAAI,UAAU;MAChEA,OAAO,CAACgB,KAAK,CAACsD,YAAY,CAAC;MAC3B,OAAO;QACLV,OAAO,EAAE,KAAK;QACd5D,OAAO,EAAEsE,YAAY;QACrBtD,KAAK,EAAEA,KAAK,CAAChB;MACf,CAAC;IACH;EACF;;EAEA;AACF;AACA;EACE,MAAMgF,WAAWA,CAAA,EAAuE;IACtF,IAAI;MACF,MAAMnD,KAAK,GAAG5B,YAAY,CAAC6B,QAAQ,CAAC,CAAC;MACrC,IAAI,CAACD,KAAK,EAAE;QACVR,OAAO,CAACC,GAAG,CAAC,gBAAgB,CAAC;QAC7B,OAAO;UAAEsC,OAAO,EAAE;QAAM,CAAC;MAC3B;MAEAvC,OAAO,CAACC,GAAG,CAAC,cAAc,EAAEO,KAAK,CAACoD,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,KAAK,CAAC;MAC3D5D,OAAO,CAACC,GAAG,CAAC,YAAY,EAAEO,KAAK,CAACqD,KAAK,CAAC,GAAG,CAAC,CAACC,MAAM,KAAK,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC;;MAEtE;MACA,IAAI,CAAClF,YAAY,CAACmF,eAAe,CAAC,CAAC,EAAE;QACnC/D,OAAO,CAACyB,IAAI,CAAC,mBAAmB,CAAC;QACjC7C,YAAY,CAAC8C,WAAW,CAAC,CAAC;QAC1BC,YAAY,CAACC,UAAU,CAAC9C,aAAa,CAAC;QACtC6C,YAAY,CAACC,UAAU,CAAC7C,sBAAsB,CAAC;QAC/C,OAAO;UAAEwD,OAAO,EAAE;QAAM,CAAC;MAC3B;;MAEA;MACAvC,OAAO,CAACC,GAAG,CAAC,YAAYpB,YAAY,SAAS,CAAC;MAC9C,MAAMgB,QAAQ,GAAG,MAAML,gBAAgB,CAAC;QACtCyB,MAAM,EAAE,KAAK;QACbE,GAAG,EAAE,GAAGtC,YAAY,SAAS;QAC7BU,OAAO,EAAE;UACP,eAAe,EAAE,UAAUiB,KAAK,EAAE;UAClC,cAAc,EAAE;QAClB;MACF,CAAC,CAAC;;MAEF;MACA,MAAMY,IAAI,GAAGvB,QAAQ,CAACuB,IAAI;MAC1BpB,OAAO,CAACC,GAAG,CAAC,OAAO,EAAEmB,IAAI,CAAC;MAE1B,IAAIA,IAAI,CAACmB,OAAO,IAAInB,IAAI,CAACA,IAAI,IAAIA,IAAI,CAACA,IAAI,CAACuB,IAAI,EAAE;QAC/C3C,OAAO,CAACC,GAAG,CAAC,iBAAiB,EAAEmB,IAAI,CAACA,IAAI,CAACuB,IAAI,CAAC;;QAE9C;QACAhB,YAAY,CAACO,OAAO,CAACnD,sBAAsB,EAAE4B,IAAI,CAACiC,GAAG,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,CAAC;QAEnE,OAAO;UAAEN,OAAO,EAAE,IAAI;UAAEI,IAAI,EAAEvB,IAAI,CAACA,IAAI,CAACuB;QAAK,CAAC;MAChD,CAAC,MAAM;QACL3C,OAAO,CAACC,GAAG,CAAC,kBAAkB,EAAEmB,IAAI,CAAC;QACrCxC,YAAY,CAAC8C,WAAW,CAAC,CAAC;QAC1BC,YAAY,CAACC,UAAU,CAAC9C,aAAa,CAAC;QACtC6C,YAAY,CAACC,UAAU,CAAC7C,sBAAsB,CAAC;QAC/C,OAAO;UAAEwD,OAAO,EAAE;QAAM,CAAC;MAC3B;IACF,CAAC,CAAC,OAAO5C,KAAU,EAAE;MAAA,IAAAqE,gBAAA,EAAAC,gBAAA;MACnBjE,OAAO,CAACL,KAAK,CAAC,SAAS,EAAEA,KAAK,CAAC;MAC/BK,OAAO,CAACL,KAAK,CAAC,QAAQ,GAAAqE,gBAAA,GAAErE,KAAK,CAACE,QAAQ,cAAAmE,gBAAA,uBAAdA,gBAAA,CAAgBjE,MAAM,CAAC;MAC/CC,OAAO,CAACL,KAAK,CAAC,OAAO,GAAAsE,gBAAA,GAAEtE,KAAK,CAACE,QAAQ,cAAAoE,gBAAA,uBAAdA,gBAAA,CAAgB7C,IAAI,CAAC;;MAE5C;MACA,MAAMxB,cAAc,GAAG,CAACD,KAAK,CAACE,QAAQ;MACtC,IAAID,cAAc,EAAE;QAClBI,OAAO,CAACyB,IAAI,CAAC,sBAAsB,CAAC;QACpC,OAAO;UACLc,OAAO,EAAE,KAAK;UACdW,YAAY,EAAE;QAChB,CAAC;MACH;;MAEA;MACA,IAAI,CAACtD,cAAc,EAAE;QACnBhB,YAAY,CAAC8C,WAAW,CAAC,CAAC;QAC1BC,YAAY,CAACC,UAAU,CAAC9C,aAAa,CAAC;QACtC6C,YAAY,CAACC,UAAU,CAAC7C,sBAAsB,CAAC;MACjD;MAEA,OAAO;QAAEwD,OAAO,EAAE;MAAM,CAAC;IAC3B;EACF;;EAEA;AACF;AACA;EACE,MAAM2B,UAAUA,CAAA,EAAuE;IACrF,IAAI;MACF,MAAM1D,KAAK,GAAG5B,YAAY,CAAC6B,QAAQ,CAAC,CAAC;MACrC,IAAI,CAACD,KAAK,EAAE;QACV,OAAO;UAAE+B,OAAO,EAAE;QAAM,CAAC;MAC3B;;MAEA;MACA,MAAM1C,QAAQ,GAAG,MAAML,gBAAgB,CAAC;QACtCyB,MAAM,EAAE,KAAK;QACbE,GAAG,EAAE,GAAGtC,YAAY,UAAU;QAC9BU,OAAO,EAAE;UACP,eAAe,EAAE,UAAUiB,KAAK,EAAE;UAClC,cAAc,EAAE;QAClB;MACF,CAAC,CAAC;;MAEF;MACA,MAAMY,IAAI,GAAGvB,QAAQ,CAACuB,IAAI;MAE1B,IAAIA,IAAI,CAACmB,OAAO,IAAInB,IAAI,CAACA,IAAI,IAAIA,IAAI,CAACA,IAAI,CAACuB,IAAI,EAAE;QAC/C;QACAhB,YAAY,CAACO,OAAO,CAACpD,aAAa,EAAE2D,IAAI,CAACC,SAAS,CAACtB,IAAI,CAACA,IAAI,CAACuB,IAAI,CAAC,CAAC;QACnEhB,YAAY,CAACO,OAAO,CAACnD,sBAAsB,EAAE4B,IAAI,CAACiC,GAAG,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,CAAC;QAEnE,OAAO;UAAEN,OAAO,EAAE,IAAI;UAAEI,IAAI,EAAEvB,IAAI,CAACA,IAAI,CAACuB;QAAK,CAAC;MAChD,CAAC,MAAM;QACL,OAAO;UAAEJ,OAAO,EAAE;QAAM,CAAC;MAC3B;IACF,CAAC,CAAC,OAAO5C,KAAU,EAAE;MAAA,IAAAwE,gBAAA;MACnBnE,OAAO,CAACL,KAAK,CAAC,WAAW,EAAEA,KAAK,CAAC;;MAEjC;MACA,MAAMC,cAAc,GAAG,CAACD,KAAK,CAACE,QAAQ;MACtC,IAAID,cAAc,EAAE;QAClB,OAAO;UACL2C,OAAO,EAAE,KAAK;UACdW,YAAY,EAAE;QAChB,CAAC;MACH;;MAEA;MACA,IAAI,EAAAiB,gBAAA,GAAAxE,KAAK,CAACE,QAAQ,cAAAsE,gBAAA,uBAAdA,gBAAA,CAAgBpE,MAAM,MAAK,GAAG,EAAE;QAClCnB,YAAY,CAAC8C,WAAW,CAAC,CAAC;QAC1BC,YAAY,CAACC,UAAU,CAAC9C,aAAa,CAAC;QACtC6C,YAAY,CAACC,UAAU,CAAC7C,sBAAsB,CAAC;MACjD;MAEA,OAAO;QAAEwD,OAAO,EAAE;MAAM,CAAC;IAC3B;EACF;;EAEA;AACF;AACA;EACE,MAAM6B,MAAMA,CAAA,EAAoD;IAC9D,IAAI;MACF,MAAM5D,KAAK,GAAG5B,YAAY,CAAC6B,QAAQ,CAAC,CAAC;MACrC,IAAID,KAAK,EAAE;QACT,IAAI;UACF;UACA,MAAMrB,OAAO,CAACkF,IAAI,CAAC,SAAS,CAAC;UAC7B;UACArE,OAAO,CAACC,GAAG,CAAC,WAAW,CAAC;QAC1B,CAAC,CAAC,OAAON,KAAK,EAAE;UACdK,OAAO,CAACyB,IAAI,CAAC,uBAAuB,EAAE9B,KAAK,CAAC;QAC9C;MACF;;MAEA;MACAf,YAAY,CAAC8C,WAAW,CAAC,CAAC;MAC1BC,YAAY,CAACC,UAAU,CAAC9C,aAAa,CAAC;MACtC6C,YAAY,CAACC,UAAU,CAAC7C,sBAAsB,CAAC;MAE/C,OAAO;QAAEwD,OAAO,EAAE,IAAI;QAAE5D,OAAO,EAAE;MAAU,CAAC;IAC9C,CAAC,CAAC,OAAOgB,KAAU,EAAE;MACnBK,OAAO,CAACL,KAAK,CAAC,SAAS,EAAEA,KAAK,CAAC;;MAE/B;MACA,IAAI;QACFf,YAAY,CAAC8C,WAAW,CAAC,CAAC;QAC1BC,YAAY,CAACC,UAAU,CAAC9C,aAAa,CAAC;QACtC6C,YAAY,CAACC,UAAU,CAAC7C,sBAAsB,CAAC;MACjD,CAAC,CAAC,OAAOuF,CAAC,EAAE;QACVtE,OAAO,CAACL,KAAK,CAAC,WAAW,EAAE2E,CAAC,CAAC;MAC/B;MAEA,OAAO;QACL/B,OAAO,EAAE,KAAK;QACd5D,OAAO,EAAE;MACX,CAAC;IACH;EACF;;EAEA;AACF;AACA;EACEoF,eAAeA,CAAA,EAAY;IACzB,OAAOnF,YAAY,CAACmF,eAAe,CAAC,CAAC;EACvC;;EAEA;AACF;AACA;EACEQ,eAAeA,CAAA,EAAoD;IACjE,MAAMR,eAAe,GAAG,IAAI,CAACA,eAAe,CAAC,CAAC;IAC9C,IAAIpB,IAAiB,GAAG,IAAI;;IAE5B;IACA,IAAIoB,eAAe,EAAE;MACnB,IAAI;QACF,MAAMS,QAAQ,GAAG7C,YAAY,CAAC2B,OAAO,CAACxE,aAAa,CAAC;QACpD,IAAI0F,QAAQ,EAAE;UACZ7B,IAAI,GAAGF,IAAI,CAACgC,KAAK,CAACD,QAAQ,CAAC;QAC7B;MACF,CAAC,CAAC,OAAOF,CAAC,EAAE;QACVtE,OAAO,CAACL,KAAK,CAAC,WAAW,EAAE2E,CAAC,CAAC;MAC/B;IACF;IAEA,OAAO;MAAEP,eAAe;MAAEpB;IAAK,CAAC;EAClC;AACF;AAEA,OAAO,MAAM+B,WAAW,GAAG,IAAItC,WAAW,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}