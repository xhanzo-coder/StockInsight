{"ast":null,"code":"var _jsxFileName = \"E:\\\\AICode\\\\StockInsight\\\\frontend\\\\src\\\\contexts\\\\AuthContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n/**\n * 认证上下文\n * 提供全局的用户状态管理\n * 使用 useReducer 管理复杂状态，提供更健壮的认证机制\n */\n\nimport React, { createContext, useContext, useEffect, useReducer } from 'react';\nimport { message } from 'antd';\nimport { authService } from '../services/authService';\nimport { tokenManager } from '../services/api';\n\n// 认证状态类型\n\n// 认证操作类型\n\n// 认证上下文类型\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// 创建认证上下文\nconst AuthContext = /*#__PURE__*/createContext(undefined);\n\n// 初始状态\nconst initialState = {\n  user: null,\n  isAuthenticated: false,\n  isLoading: true,\n  error: null,\n  lastVerified: null,\n  tokenRefreshInProgress: false,\n  networkError: false\n};\n\n// 认证状态reducer\nconst authReducer = (state, action) => {\n  switch (action.type) {\n    case 'AUTH_INIT':\n      return {\n        ...state,\n        isLoading: true,\n        error: null,\n        networkError: false\n      };\n    case 'AUTH_SUCCESS':\n      return {\n        ...state,\n        user: action.payload.user,\n        isAuthenticated: true,\n        isLoading: false,\n        error: null,\n        lastVerified: Date.now(),\n        networkError: false\n      };\n    case 'AUTH_FAILURE':\n      return {\n        ...state,\n        user: null,\n        isAuthenticated: false,\n        isLoading: false,\n        error: action.payload.error,\n        lastVerified: Date.now()\n      };\n    case 'AUTH_RESET':\n      return {\n        ...initialState,\n        isLoading: false\n      };\n    case 'SET_LOADING':\n      return {\n        ...state,\n        isLoading: action.payload.isLoading\n      };\n    case 'SET_NETWORK_ERROR':\n      return {\n        ...state,\n        networkError: action.payload.networkError\n      };\n    case 'TOKEN_REFRESH_START':\n      return {\n        ...state,\n        tokenRefreshInProgress: true\n      };\n    case 'TOKEN_REFRESH_END':\n      return {\n        ...state,\n        tokenRefreshInProgress: false\n      };\n    default:\n      return state;\n  }\n};\n\n// 本地存储键\nconst USER_INFO_KEY = 'userInfo';\nconst AUTH_LAST_VERIFIED_KEY = 'auth_last_verified';\n\n// 认证提供者组件\n\nexport const AuthProvider = ({\n  children\n}) => {\n  _s();\n  const [state, dispatch] = useReducer(authReducer, initialState);\n\n  // 验证会话有效性\n  const verifySession = async () => {\n    // 如果没有token，直接返回false\n    const token = tokenManager.getToken();\n    if (!token) {\n      console.log('没有找到token，会话无效');\n      return false;\n    }\n\n    // 检查token格式是否有效\n    const tokenParts = token.split('.');\n    if (tokenParts.length !== 3) {\n      console.warn('token格式无效，清除认证状态');\n      await handleLogout(false);\n      return false;\n    }\n\n    // 如果正在刷新token，等待完成\n    if (state.tokenRefreshInProgress) {\n      console.log('token刷新进行中，使用当前认证状态');\n      return state.isAuthenticated;\n    }\n\n    // 检查上次验证时间，如果在5分钟内验证过，直接返回当前状态\n    const lastVerified = state.lastVerified || Number(localStorage.getItem(AUTH_LAST_VERIFIED_KEY)) || 0;\n    const now = Date.now();\n    const fiveMinutes = 5 * 60 * 1000;\n    if (now - lastVerified < fiveMinutes && state.user) {\n      console.log('会话在5分钟内已验证，跳过验证');\n      return state.isAuthenticated;\n    }\n\n    // 开始验证token\n    console.log('开始验证token...');\n    dispatch({\n      type: 'TOKEN_REFRESH_START'\n    });\n    try {\n      console.log('验证会话有效性...');\n      const result = await authService.verifyToken();\n      if (result.success && result.user) {\n        // 更新用户信息和验证时间\n        console.log('会话验证成功，更新用户信息');\n        dispatch({\n          type: 'AUTH_SUCCESS',\n          payload: {\n            user: result.user\n          }\n        });\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        return true;\n      } else {\n        // 验证失败，清除状态\n        console.warn('会话验证失败，清除认证状态');\n        await handleLogout(false);\n        return false;\n      }\n    } catch (error) {\n      console.error('会话验证出错:', error);\n\n      // 网络错误时不清除本地状态，但标记网络错误\n      if (error instanceof Error && error.message.includes('Network Error')) {\n        console.warn('网络错误，保持当前认证状态');\n        dispatch({\n          type: 'SET_NETWORK_ERROR',\n          payload: {\n            networkError: true\n          }\n        });\n        message.error('网络连接错误，请检查网络连接');\n        return state.isAuthenticated; // 网络错误时保持当前状态\n      }\n\n      // 其他错误清除状态\n      console.warn('会话验证出错，清除认证状态');\n      await handleLogout(false);\n      return false;\n    } finally {\n      dispatch({\n        type: 'TOKEN_REFRESH_END'\n      });\n    }\n  };\n\n  // 初始化认证状态\n  useEffect(() => {\n    const initAuth = async () => {\n      dispatch({\n        type: 'AUTH_INIT'\n      });\n      try {\n        // 检查localStorage中是否有token\n        if (tokenManager.isAuthenticated()) {\n          console.log('发现本地存储的token，正在初始化认证状态...');\n\n          // 尝试从localStorage恢复用户信息\n          const storedUserInfo = localStorage.getItem(USER_INFO_KEY);\n          if (storedUserInfo) {\n            try {\n              const parsedUserInfo = JSON.parse(storedUserInfo);\n              console.log('从localStorage恢复用户信息:', parsedUserInfo);\n\n              // 先设置用户信息，以便快速显示UI\n              dispatch({\n                type: 'AUTH_SUCCESS',\n                payload: {\n                  user: parsedUserInfo\n                }\n              });\n\n              // 然后异步验证token有效性\n              verifySession().catch(error => {\n                console.error('会话验证失败:', error);\n              });\n            } catch (e) {\n              console.error('解析localStorage中的用户信息失败:', e);\n              dispatch({\n                type: 'AUTH_FAILURE',\n                payload: {\n                  error: '用户信息解析失败'\n                }\n              });\n            }\n          } else {\n            // 有token但没有用户信息，验证token\n            const verified = await verifySession();\n            if (!verified) {\n              dispatch({\n                type: 'AUTH_FAILURE',\n                payload: {\n                  error: '会话已过期'\n                }\n              });\n            }\n          }\n        } else {\n          console.log('未找到token，用户未登录');\n          dispatch({\n            type: 'AUTH_RESET'\n          });\n        }\n      } catch (error) {\n        console.error('初始化认证时出错:', error);\n        dispatch({\n          type: 'AUTH_FAILURE',\n          payload: {\n            error: '认证初始化失败'\n          }\n        });\n      }\n    };\n    initAuth();\n\n    // 设置定期验证会话的定时器（每15分钟）\n    const sessionCheckInterval = setInterval(() => {\n      if (tokenManager.isAuthenticated() && state.user) {\n        console.log('定期验证会话...');\n        verifySession().catch(error => {\n          console.error('定期会话验证失败:', error);\n        });\n      }\n    }, 15 * 60 * 1000);\n\n    // 监听存储事件，实现多标签页同步\n    const handleStorageChange = event => {\n      if (event.key === 'auth_token' && !event.newValue) {\n        // 其他标签页删除了token，同步登出\n        console.log('检测到其他标签页登出，同步登出状态');\n        dispatch({\n          type: 'AUTH_RESET'\n        });\n      }\n    };\n    window.addEventListener('storage', handleStorageChange);\n    return () => {\n      clearInterval(sessionCheckInterval);\n      window.removeEventListener('storage', handleStorageChange);\n    };\n  }, []);\n\n  // 处理登出逻辑\n  const handleLogout = async (callApi = true) => {\n    try {\n      if (callApi) {\n        // 调用后端登出API\n        await authService.logout().catch(error => {\n          console.warn('登出API调用失败:', error);\n        });\n      }\n    } finally {\n      // 无论API调用成功与否，都清除本地状态\n      tokenManager.removeToken();\n      localStorage.removeItem(USER_INFO_KEY);\n      localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      dispatch({\n        type: 'AUTH_RESET'\n      });\n    }\n  };\n\n  // 登录方法\n  const login = async (username, password) => {\n    dispatch({\n      type: 'AUTH_INIT'\n    });\n    try {\n      const result = await authService.login({\n        username,\n        password\n      });\n      if (result.success && result.data) {\n        // 登录成功，更新状态\n        dispatch({\n          type: 'AUTH_SUCCESS',\n          payload: {\n            user: result.data.user\n          }\n        });\n\n        // 保存用户信息到localStorage\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        message.success('登录成功！');\n        return true;\n      } else {\n        // 登录失败，显示错误\n        dispatch({\n          type: 'AUTH_FAILURE',\n          payload: {\n            error: result.message || '登录失败'\n          }\n        });\n        return false;\n      }\n    } catch (error) {\n      console.error('登录过程出错:', error);\n\n      // 网络错误特殊处理\n      if (error.message && error.message.includes('Network Error')) {\n        dispatch({\n          type: 'SET_NETWORK_ERROR',\n          payload: {\n            networkError: true\n          }\n        });\n        message.error('网络连接错误，请检查网络连接');\n      } else {\n        dispatch({\n          type: 'AUTH_FAILURE',\n          payload: {\n            error: '登录失败，请重试'\n          }\n        });\n      }\n      return false;\n    }\n  };\n\n  // 注册方法\n  const register = async (username, email, password) => {\n    dispatch({\n      type: 'AUTH_INIT'\n    });\n    try {\n      const result = await authService.register({\n        username,\n        email,\n        password\n      });\n      if (result.success && result.data) {\n        // 注册成功，更新状态\n        dispatch({\n          type: 'AUTH_SUCCESS',\n          payload: {\n            user: result.data.user\n          }\n        });\n\n        // 保存用户信息到localStorage\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        message.success('注册成功！');\n        return true;\n      } else {\n        // 注册失败，显示错误\n        dispatch({\n          type: 'AUTH_FAILURE',\n          payload: {\n            error: result.message || '注册失败'\n          }\n        });\n        return false;\n      }\n    } catch (error) {\n      console.error('注册过程出错:', error);\n\n      // 网络错误特殊处理\n      if (error.message && error.message.includes('Network Error')) {\n        dispatch({\n          type: 'SET_NETWORK_ERROR',\n          payload: {\n            networkError: true\n          }\n        });\n        message.error('网络连接错误，请检查网络连接');\n      } else {\n        dispatch({\n          type: 'AUTH_FAILURE',\n          payload: {\n            error: '注册失败，请重试'\n          }\n        });\n      }\n      return false;\n    }\n  };\n\n  // 登出方法\n  const logout = async () => {\n    await handleLogout(true);\n    message.success('已安全退出登录');\n  };\n\n  // 刷新用户信息\n  const refreshUser = async () => {\n    if (!tokenManager.isAuthenticated() || !state.user) {\n      return;\n    }\n    try {\n      const result = await authService.getProfile();\n      if (result.success && result.user) {\n        // 更新用户信息\n        dispatch({\n          type: 'AUTH_SUCCESS',\n          payload: {\n            user: result.user\n          }\n        });\n\n        // 更新localStorage中的用户信息\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n      }\n    } catch (error) {\n      console.error('刷新用户信息失败:', error);\n\n      // 网络错误不清除状态\n      if (error instanceof Error && error.message.includes('Network Error')) {\n        dispatch({\n          type: 'SET_NETWORK_ERROR',\n          payload: {\n            networkError: true\n          }\n        });\n        message.error('网络连接错误，请检查网络连接');\n      }\n    }\n  };\n\n  // 提供上下文值\n  const contextValue = {\n    ...state,\n    login,\n    register,\n    logout,\n    refreshUser,\n    verifySession\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 455,\n    columnNumber: 5\n  }, this);\n};\n\n// 使用认证上下文的Hook\n_s(AuthProvider, \"bgCdjuTOmPdSBRwTap80EFd9Y3U=\");\n_c = AuthProvider;\nexport const useAuth = () => {\n  _s2();\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n_s2(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useReducer","message","authService","tokenManager","jsxDEV","_jsxDEV","AuthContext","undefined","initialState","user","isAuthenticated","isLoading","error","lastVerified","tokenRefreshInProgress","networkError","authReducer","state","action","type","payload","Date","now","USER_INFO_KEY","AUTH_LAST_VERIFIED_KEY","AuthProvider","children","_s","dispatch","verifySession","token","getToken","console","log","tokenParts","split","length","warn","handleLogout","Number","localStorage","getItem","fiveMinutes","result","verifyToken","success","setItem","JSON","stringify","toString","Error","includes","initAuth","storedUserInfo","parsedUserInfo","parse","catch","e","verified","sessionCheckInterval","setInterval","handleStorageChange","event","key","newValue","window","addEventListener","clearInterval","removeEventListener","callApi","logout","removeToken","removeItem","login","username","password","data","register","email","refreshUser","getProfile","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useAuth","_s2","context","$RefreshReg$"],"sources":["E:/AICode/StockInsight/frontend/src/contexts/AuthContext.tsx"],"sourcesContent":["/**\n * 认证上下文\n * 提供全局的用户状态管理\n * 使用 useReducer 管理复杂状态，提供更健壮的认证机制\n */\n\nimport React, { createContext, useContext, useEffect, useReducer, ReactNode } from 'react';\nimport { message } from 'antd';\nimport { authService, User } from '../services/authService';\nimport { tokenManager } from '../services/api';\n\n// 认证状态类型\ninterface AuthState {\n  user: User | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  error: string | null;\n  lastVerified: number | null; // 上次验证时间戳\n  tokenRefreshInProgress: boolean; // 是否正在刷新token\n  networkError: boolean; // 是否存在网络错误\n}\n\n// 认证操作类型\ntype AuthAction =\n  | { type: 'AUTH_INIT' }\n  | { type: 'AUTH_SUCCESS'; payload: { user: User } }\n  | { type: 'AUTH_FAILURE'; payload: { error: string } }\n  | { type: 'AUTH_RESET' }\n  | { type: 'SET_LOADING'; payload: { isLoading: boolean } }\n  | { type: 'SET_NETWORK_ERROR'; payload: { networkError: boolean } }\n  | { type: 'TOKEN_REFRESH_START' }\n  | { type: 'TOKEN_REFRESH_END' };\n\n// 认证上下文类型\ninterface AuthContextType extends AuthState {\n  login: (username: string, password: string) => Promise<boolean>;\n  register: (username: string, email: string, password: string) => Promise<boolean>;\n  logout: () => Promise<void>;\n  refreshUser: () => Promise<void>;\n  verifySession: () => Promise<boolean>; // 新增：验证会话有效性\n}\n\n// 创建认证上下文\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\n// 初始状态\nconst initialState: AuthState = {\n  user: null,\n  isAuthenticated: false,\n  isLoading: true,\n  error: null,\n  lastVerified: null,\n  tokenRefreshInProgress: false,\n  networkError: false\n};\n\n// 认证状态reducer\nconst authReducer = (state: AuthState, action: AuthAction): AuthState => {\n  switch (action.type) {\n    case 'AUTH_INIT':\n      return {\n        ...state,\n        isLoading: true,\n        error: null,\n        networkError: false\n      };\n    case 'AUTH_SUCCESS':\n      return {\n        ...state,\n        user: action.payload.user,\n        isAuthenticated: true,\n        isLoading: false,\n        error: null,\n        lastVerified: Date.now(),\n        networkError: false\n      };\n    case 'AUTH_FAILURE':\n      return {\n        ...state,\n        user: null,\n        isAuthenticated: false,\n        isLoading: false,\n        error: action.payload.error,\n        lastVerified: Date.now()\n      };\n    case 'AUTH_RESET':\n      return {\n        ...initialState,\n        isLoading: false\n      };\n    case 'SET_LOADING':\n      return {\n        ...state,\n        isLoading: action.payload.isLoading\n      };\n    case 'SET_NETWORK_ERROR':\n      return {\n        ...state,\n        networkError: action.payload.networkError\n      };\n    case 'TOKEN_REFRESH_START':\n      return {\n        ...state,\n        tokenRefreshInProgress: true\n      };\n    case 'TOKEN_REFRESH_END':\n      return {\n        ...state,\n        tokenRefreshInProgress: false\n      };\n    default:\n      return state;\n  }\n};\n\n// 本地存储键\nconst USER_INFO_KEY = 'userInfo';\nconst AUTH_LAST_VERIFIED_KEY = 'auth_last_verified';\n\n// 认证提供者组件\ninterface AuthProviderProps {\n  children: ReactNode;\n}\n\nexport const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {\n  const [state, dispatch] = useReducer(authReducer, initialState);\n\n  // 验证会话有效性\n  const verifySession = async (): Promise<boolean> => {\n    // 如果没有token，直接返回false\n    const token = tokenManager.getToken();\n    if (!token) {\n      console.log('没有找到token，会话无效');\n      return false;\n    }\n\n    // 检查token格式是否有效\n    const tokenParts = token.split('.');\n    if (tokenParts.length !== 3) {\n      console.warn('token格式无效，清除认证状态');\n      await handleLogout(false);\n      return false;\n    }\n\n    // 如果正在刷新token，等待完成\n    if (state.tokenRefreshInProgress) {\n      console.log('token刷新进行中，使用当前认证状态');\n      return state.isAuthenticated;\n    }\n\n    // 检查上次验证时间，如果在5分钟内验证过，直接返回当前状态\n    const lastVerified = state.lastVerified || Number(localStorage.getItem(AUTH_LAST_VERIFIED_KEY)) || 0;\n    const now = Date.now();\n    const fiveMinutes = 5 * 60 * 1000;\n    \n    if (now - lastVerified < fiveMinutes && state.user) {\n      console.log('会话在5分钟内已验证，跳过验证');\n      return state.isAuthenticated;\n    }\n\n    // 开始验证token\n    console.log('开始验证token...');\n    dispatch({ type: 'TOKEN_REFRESH_START' });\n    \n    try {\n      console.log('验证会话有效性...');\n      const result = await authService.verifyToken();\n      \n      if (result.success && result.user) {\n        // 更新用户信息和验证时间\n        console.log('会话验证成功，更新用户信息');\n        dispatch({ type: 'AUTH_SUCCESS', payload: { user: result.user } });\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        return true;\n      } else {\n        // 验证失败，清除状态\n        console.warn('会话验证失败，清除认证状态');\n        await handleLogout(false);\n        return false;\n      }\n    } catch (error) {\n      console.error('会话验证出错:', error);\n      \n      // 网络错误时不清除本地状态，但标记网络错误\n      if (error instanceof Error && error.message.includes('Network Error')) {\n        console.warn('网络错误，保持当前认证状态');\n        dispatch({ type: 'SET_NETWORK_ERROR', payload: { networkError: true } });\n        message.error('网络连接错误，请检查网络连接');\n        return state.isAuthenticated; // 网络错误时保持当前状态\n      }\n      \n      // 其他错误清除状态\n      console.warn('会话验证出错，清除认证状态');\n      await handleLogout(false);\n      return false;\n    } finally {\n      dispatch({ type: 'TOKEN_REFRESH_END' });\n    }\n  };\n\n  // 初始化认证状态\n  useEffect(() => {\n    const initAuth = async () => {\n      dispatch({ type: 'AUTH_INIT' });\n      \n      try {\n        // 检查localStorage中是否有token\n        if (tokenManager.isAuthenticated()) {\n          console.log('发现本地存储的token，正在初始化认证状态...');\n          \n          // 尝试从localStorage恢复用户信息\n          const storedUserInfo = localStorage.getItem(USER_INFO_KEY);\n          if (storedUserInfo) {\n            try {\n              const parsedUserInfo = JSON.parse(storedUserInfo);\n              console.log('从localStorage恢复用户信息:', parsedUserInfo);\n              \n              // 先设置用户信息，以便快速显示UI\n              dispatch({ \n                type: 'AUTH_SUCCESS', \n                payload: { user: parsedUserInfo } \n              });\n              \n              // 然后异步验证token有效性\n              verifySession().catch(error => {\n                console.error('会话验证失败:', error);\n              });\n            } catch (e) {\n              console.error('解析localStorage中的用户信息失败:', e);\n              dispatch({ \n                type: 'AUTH_FAILURE', \n                payload: { error: '用户信息解析失败' } \n              });\n            }\n          } else {\n            // 有token但没有用户信息，验证token\n            const verified = await verifySession();\n            if (!verified) {\n              dispatch({ \n                type: 'AUTH_FAILURE', \n                payload: { error: '会话已过期' } \n              });\n            }\n          }\n        } else {\n          console.log('未找到token，用户未登录');\n          dispatch({ type: 'AUTH_RESET' });\n        }\n      } catch (error) {\n        console.error('初始化认证时出错:', error);\n        dispatch({ \n          type: 'AUTH_FAILURE', \n          payload: { error: '认证初始化失败' } \n        });\n      }\n    };\n\n    initAuth();\n    \n    // 设置定期验证会话的定时器（每15分钟）\n    const sessionCheckInterval = setInterval(() => {\n      if (tokenManager.isAuthenticated() && state.user) {\n        console.log('定期验证会话...');\n        verifySession().catch(error => {\n          console.error('定期会话验证失败:', error);\n        });\n      }\n    }, 15 * 60 * 1000);\n    \n    // 监听存储事件，实现多标签页同步\n    const handleStorageChange = (event: StorageEvent) => {\n      if (event.key === 'auth_token' && !event.newValue) {\n        // 其他标签页删除了token，同步登出\n        console.log('检测到其他标签页登出，同步登出状态');\n        dispatch({ type: 'AUTH_RESET' });\n      }\n    };\n    \n    window.addEventListener('storage', handleStorageChange);\n    \n    return () => {\n      clearInterval(sessionCheckInterval);\n      window.removeEventListener('storage', handleStorageChange);\n    };\n  }, []);\n\n  // 处理登出逻辑\n  const handleLogout = async (callApi: boolean = true): Promise<void> => {\n    try {\n      if (callApi) {\n        // 调用后端登出API\n        await authService.logout().catch(error => {\n          console.warn('登出API调用失败:', error);\n        });\n      }\n    } finally {\n      // 无论API调用成功与否，都清除本地状态\n      tokenManager.removeToken();\n      localStorage.removeItem(USER_INFO_KEY);\n      localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      dispatch({ type: 'AUTH_RESET' });\n    }\n  };\n\n  // 登录方法\n  const login = async (username: string, password: string): Promise<boolean> => {\n    dispatch({ type: 'AUTH_INIT' });\n    \n    try {\n      const result = await authService.login({ username, password });\n      \n      if (result.success && result.data) {\n        // 登录成功，更新状态\n        dispatch({ \n          type: 'AUTH_SUCCESS', \n          payload: { user: result.data.user } \n        });\n        \n        // 保存用户信息到localStorage\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        \n        message.success('登录成功！');\n        return true;\n      } else {\n        // 登录失败，显示错误\n        dispatch({ \n          type: 'AUTH_FAILURE', \n          payload: { error: result.message || '登录失败' } \n        });\n        return false;\n      }\n    } catch (error: any) {\n      console.error('登录过程出错:', error);\n      \n      // 网络错误特殊处理\n      if (error.message && error.message.includes('Network Error')) {\n        dispatch({ \n          type: 'SET_NETWORK_ERROR', \n          payload: { networkError: true } \n        });\n        message.error('网络连接错误，请检查网络连接');\n      } else {\n        dispatch({ \n          type: 'AUTH_FAILURE', \n          payload: { error: '登录失败，请重试' } \n        });\n      }\n      \n      return false;\n    }\n  };\n\n  // 注册方法\n  const register = async (username: string, email: string, password: string): Promise<boolean> => {\n    dispatch({ type: 'AUTH_INIT' });\n    \n    try {\n      const result = await authService.register({ username, email, password });\n      \n      if (result.success && result.data) {\n        // 注册成功，更新状态\n        dispatch({ \n          type: 'AUTH_SUCCESS', \n          payload: { user: result.data.user } \n        });\n        \n        // 保存用户信息到localStorage\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        \n        message.success('注册成功！');\n        return true;\n      } else {\n        // 注册失败，显示错误\n        dispatch({ \n          type: 'AUTH_FAILURE', \n          payload: { error: result.message || '注册失败' } \n        });\n        return false;\n      }\n    } catch (error: any) {\n      console.error('注册过程出错:', error);\n      \n      // 网络错误特殊处理\n      if (error.message && error.message.includes('Network Error')) {\n        dispatch({ \n          type: 'SET_NETWORK_ERROR', \n          payload: { networkError: true } \n        });\n        message.error('网络连接错误，请检查网络连接');\n      } else {\n        dispatch({ \n          type: 'AUTH_FAILURE', \n          payload: { error: '注册失败，请重试' } \n        });\n      }\n      \n      return false;\n    }\n  };\n\n  // 登出方法\n  const logout = async (): Promise<void> => {\n    await handleLogout(true);\n    message.success('已安全退出登录');\n  };\n\n  // 刷新用户信息\n  const refreshUser = async (): Promise<void> => {\n    if (!tokenManager.isAuthenticated() || !state.user) {\n      return;\n    }\n    \n    try {\n      const result = await authService.getProfile();\n      \n      if (result.success && result.user) {\n        // 更新用户信息\n        dispatch({ \n          type: 'AUTH_SUCCESS', \n          payload: { user: result.user } \n        });\n        \n        // 更新localStorage中的用户信息\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n      }\n    } catch (error) {\n      console.error('刷新用户信息失败:', error);\n      \n      // 网络错误不清除状态\n      if (error instanceof Error && error.message.includes('Network Error')) {\n        dispatch({ \n          type: 'SET_NETWORK_ERROR', \n          payload: { networkError: true } \n        });\n        message.error('网络连接错误，请检查网络连接');\n      }\n    }\n  };\n\n  // 提供上下文值\n  const contextValue: AuthContextType = {\n    ...state,\n    login,\n    register,\n    logout,\n    refreshUser,\n    verifySession\n  };\n\n  return (\n    <AuthContext.Provider value={contextValue}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\n// 使用认证上下文的Hook\nexport const useAuth = (): AuthContextType => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}