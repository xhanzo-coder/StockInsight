{"ast":null,"code":"/**\n * 认证上下文\n * 提供全局的用户状态管理\n * 使用 useReducer 管理复杂状态，提供更健壮的认证机制\n */import React,{createContext,useContext,useEffect,useReducer}from'react';import{message}from'antd';import{authService}from'../services/authService';import{tokenManager}from'../services/api';// 认证状态类型\n// 认证操作类型\n// 认证上下文类型\nimport{jsx as _jsx}from\"react/jsx-runtime\";// 创建认证上下文\nconst AuthContext=/*#__PURE__*/createContext(undefined);// 初始状态\nconst initialState={user:null,isAuthenticated:false,isLoading:true,error:null,lastVerified:null,tokenRefreshInProgress:false,networkError:false};// 认证状态reducer\nconst authReducer=(state,action)=>{switch(action.type){case'AUTH_INIT':return{...state,isLoading:true,error:null,networkError:false};case'AUTH_SUCCESS':return{...state,user:action.payload.user,isAuthenticated:true,isLoading:false,error:null,lastVerified:Date.now(),networkError:false};case'AUTH_FAILURE':return{...state,user:null,isAuthenticated:false,isLoading:false,error:action.payload.error,lastVerified:Date.now()};case'AUTH_RESET':return{...initialState,isLoading:false};case'SET_LOADING':return{...state,isLoading:action.payload.isLoading};case'SET_NETWORK_ERROR':return{...state,networkError:action.payload.networkError};case'TOKEN_REFRESH_START':return{...state,tokenRefreshInProgress:true};case'TOKEN_REFRESH_END':return{...state,tokenRefreshInProgress:false};default:return state;}};// 本地存储键\nconst USER_INFO_KEY='userInfo';const AUTH_LAST_VERIFIED_KEY='auth_last_verified';// 认证提供者组件\nexport const AuthProvider=_ref=>{let{children}=_ref;const[state,dispatch]=useReducer(authReducer,initialState);// 验证会话有效性\nconst verifySession=async()=>{// 如果没有token，直接返回false\nconst token=tokenManager.getToken();if(!token){console.log('没有找到token，会话无效');return false;}// 检查token格式是否有效\nconst tokenParts=token.split('.');if(tokenParts.length!==3){console.warn('token格式无效，清除认证状态');await handleLogout(false);return false;}// 如果正在刷新token，等待完成\nif(state.tokenRefreshInProgress){console.log('token刷新进行中，使用当前认证状态');return state.isAuthenticated;}// 检查token是否过期（通过解析JWT的payload）\ntry{const payload=JSON.parse(atob(tokenParts[1]));if(payload.exp&&payload.exp*1000<Date.now()){console.warn('token已过期，清除认证状态');await handleLogout(false);return false;}}catch(e){console.warn('无法解析token payload:',e);// 继续验证，让服务器决定token是否有效\n}// 检查上次验证时间，如果在5分钟内验证过，直接返回当前状态\nconst lastVerified=state.lastVerified||Number(localStorage.getItem(AUTH_LAST_VERIFIED_KEY))||0;const now=Date.now();const fiveMinutes=5*60*1000;if(now-lastVerified<fiveMinutes&&state.user){console.log('会话在5分钟内已验证，跳过验证，直接使用当前状态');// 确保状态是已认证的\nif(!state.isAuthenticated&&state.user){console.log('状态不一致，更新认证状态为已认证');dispatch({type:'AUTH_SUCCESS',payload:{user:state.user}});}return true;}// 开始验证token\nconsole.log('开始验证token...');dispatch({type:'TOKEN_REFRESH_START'});try{console.log('验证会话有效性...');const result=await authService.verifyToken();if(result.success&&result.user){// 更新用户信息和验证时间\nconsole.log('会话验证成功，更新用户信息');dispatch({type:'AUTH_SUCCESS',payload:{user:result.user}});localStorage.setItem(USER_INFO_KEY,JSON.stringify(result.user));localStorage.setItem(AUTH_LAST_VERIFIED_KEY,Date.now().toString());return true;}else if(result.networkError){// 网络错误时，如果有用户信息，保持认证状态\nconsole.warn('网络错误，检查本地用户信息');const storedUserInfo=localStorage.getItem(USER_INFO_KEY);if(storedUserInfo){try{const parsedUserInfo=JSON.parse(storedUserInfo);console.log('使用本地存储的用户信息:',parsedUserInfo);dispatch({type:'AUTH_SUCCESS',payload:{user:parsedUserInfo}});dispatch({type:'SET_NETWORK_ERROR',payload:{networkError:true}});return true;}catch(e){console.error('解析本地用户信息失败:',e);}}// 没有可用的用户信息，标记网络错误\ndispatch({type:'SET_NETWORK_ERROR',payload:{networkError:true}});message.error('网络连接错误，请检查网络连接');return state.isAuthenticated;// 网络错误时保持当前状态\n}else{// 验证失败，清除状态\nconsole.warn('会话验证失败，清除认证状态');await handleLogout(false);return false;}}catch(error){console.error('会话验证出错:',error);// 网络错误时不清除本地状态，但标记网络错误\nif(error instanceof Error&&error.message.includes('Network Error')){console.warn('网络错误，保持当前认证状态');dispatch({type:'SET_NETWORK_ERROR',payload:{networkError:true}});message.error('网络连接错误，请检查网络连接');return state.isAuthenticated;// 网络错误时保持当前状态\n}// 其他错误清除状态\nconsole.warn('会话验证出错，清除认证状态');await handleLogout(false);return false;}finally{dispatch({type:'TOKEN_REFRESH_END'});}};// 初始化认证状态\nuseEffect(()=>{const initAuth=async()=>{dispatch({type:'AUTH_INIT'});try{// 检查localStorage中是否有token\nif(tokenManager.isAuthenticated()){console.log('发现本地存储的token，正在初始化认证状态...');// 尝试从localStorage恢复用户信息\nconst storedUserInfo=localStorage.getItem(USER_INFO_KEY);if(storedUserInfo){try{const parsedUserInfo=JSON.parse(storedUserInfo);console.log('从localStorage恢复用户信息:',parsedUserInfo);// 先设置用户信息，以便快速显示UI\ndispatch({type:'AUTH_SUCCESS',payload:{user:parsedUserInfo}});// 然后异步验证token有效性\nverifySession().catch(error=>{console.error('会话验证失败:',error);});}catch(e){console.error('解析localStorage中的用户信息失败:',e);dispatch({type:'AUTH_FAILURE',payload:{error:'用户信息解析失败'}});}}else{// 有token但没有用户信息，验证token\nconst verified=await verifySession();if(!verified){dispatch({type:'AUTH_FAILURE',payload:{error:'会话已过期'}});}}}else{console.log('未找到token，用户未登录');dispatch({type:'AUTH_RESET'});}}catch(error){console.error('初始化认证时出错:',error);dispatch({type:'AUTH_FAILURE',payload:{error:'认证初始化失败'}});}};initAuth();// 设置定期验证会话的定时器（每15分钟）\nconst sessionCheckInterval=setInterval(()=>{if(tokenManager.isAuthenticated()&&state.user){console.log('定期验证会话...');verifySession().catch(error=>{console.error('定期会话验证失败:',error);});}},15*60*1000);// 监听存储事件，实现多标签页同步\nconst handleStorageChange=event=>{if(event.key==='auth_token'&&!event.newValue){// 其他标签页删除了token，同步登出\nconsole.log('检测到其他标签页登出，同步登出状态');dispatch({type:'AUTH_RESET'});}};window.addEventListener('storage',handleStorageChange);return()=>{clearInterval(sessionCheckInterval);window.removeEventListener('storage',handleStorageChange);};},[]);// 处理登出逻辑\nconst handleLogout=async function(){let callApi=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;try{if(callApi){// 调用后端登出API\nawait authService.logout().catch(error=>{console.warn('登出API调用失败:',error);});}}finally{// 无论API调用成功与否，都清除本地状态\ntokenManager.removeToken();localStorage.removeItem(USER_INFO_KEY);localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);dispatch({type:'AUTH_RESET'});}};// 登录方法\nconst login=async(username,password)=>{dispatch({type:'AUTH_INIT'});try{const result=await authService.login({username,password});if(result.success&&result.data){// 登录成功，更新状态\ndispatch({type:'AUTH_SUCCESS',payload:{user:result.data.user}});// 保存用户信息到localStorage\nlocalStorage.setItem(USER_INFO_KEY,JSON.stringify(result.data.user));localStorage.setItem(AUTH_LAST_VERIFIED_KEY,Date.now().toString());message.success('登录成功！');return true;}else{// 登录失败，显示错误\ndispatch({type:'AUTH_FAILURE',payload:{error:result.message||'登录失败'}});return false;}}catch(error){console.error('登录过程出错:',error);// 网络错误特殊处理\nif(error.message&&error.message.includes('Network Error')){dispatch({type:'SET_NETWORK_ERROR',payload:{networkError:true}});message.error('网络连接错误，请检查网络连接');}else{dispatch({type:'AUTH_FAILURE',payload:{error:'登录失败，请重试'}});}return false;}};// 注册方法\nconst register=async(username,email,password)=>{dispatch({type:'AUTH_INIT'});try{const result=await authService.register({username,email,password});if(result.success&&result.data){// 注册成功，更新状态\ndispatch({type:'AUTH_SUCCESS',payload:{user:result.data.user}});// 保存用户信息到localStorage\nlocalStorage.setItem(USER_INFO_KEY,JSON.stringify(result.data.user));localStorage.setItem(AUTH_LAST_VERIFIED_KEY,Date.now().toString());message.success('注册成功！');return true;}else{// 注册失败，显示错误\ndispatch({type:'AUTH_FAILURE',payload:{error:result.message||'注册失败'}});return false;}}catch(error){console.error('注册过程出错:',error);// 网络错误特殊处理\nif(error.message&&error.message.includes('Network Error')){dispatch({type:'SET_NETWORK_ERROR',payload:{networkError:true}});message.error('网络连接错误，请检查网络连接');}else{dispatch({type:'AUTH_FAILURE',payload:{error:'注册失败，请重试'}});}return false;}};// 登出方法\nconst logout=async()=>{await handleLogout(true);message.success('已安全退出登录');};// 刷新用户信息\nconst refreshUser=async()=>{if(!tokenManager.isAuthenticated()||!state.user){return;}try{const result=await authService.getProfile();if(result.success&&result.user){// 更新用户信息\ndispatch({type:'AUTH_SUCCESS',payload:{user:result.user}});// 更新localStorage中的用户信息\nlocalStorage.setItem(USER_INFO_KEY,JSON.stringify(result.user));localStorage.setItem(AUTH_LAST_VERIFIED_KEY,Date.now().toString());}}catch(error){console.error('刷新用户信息失败:',error);// 网络错误不清除状态\nif(error instanceof Error&&error.message.includes('Network Error')){dispatch({type:'SET_NETWORK_ERROR',payload:{networkError:true}});message.error('网络连接错误，请检查网络连接');}}};// 提供上下文值\nconst contextValue={...state,login,register,logout,refreshUser,verifySession};return/*#__PURE__*/_jsx(AuthContext.Provider,{value:contextValue,children:children});};// 使用认证上下文的Hook\nexport const useAuth=()=>{const context=useContext(AuthContext);if(context===undefined){throw new Error('useAuth must be used within an AuthProvider');}return context;};","map":{"version":3,"names":["React","createContext","useContext","useEffect","useReducer","message","authService","tokenManager","jsx","_jsx","AuthContext","undefined","initialState","user","isAuthenticated","isLoading","error","lastVerified","tokenRefreshInProgress","networkError","authReducer","state","action","type","payload","Date","now","USER_INFO_KEY","AUTH_LAST_VERIFIED_KEY","AuthProvider","_ref","children","dispatch","verifySession","token","getToken","console","log","tokenParts","split","length","warn","handleLogout","JSON","parse","atob","exp","e","Number","localStorage","getItem","fiveMinutes","result","verifyToken","success","setItem","stringify","toString","storedUserInfo","parsedUserInfo","Error","includes","initAuth","catch","verified","sessionCheckInterval","setInterval","handleStorageChange","event","key","newValue","window","addEventListener","clearInterval","removeEventListener","callApi","arguments","logout","removeToken","removeItem","login","username","password","data","register","email","refreshUser","getProfile","contextValue","Provider","value","useAuth","context"],"sources":["E:/AICode/StockInsight/frontend/src/contexts/AuthContext.tsx"],"sourcesContent":["/**\n * 认证上下文\n * 提供全局的用户状态管理\n * 使用 useReducer 管理复杂状态，提供更健壮的认证机制\n */\n\nimport React, { createContext, useContext, useEffect, useReducer, ReactNode } from 'react';\nimport { message } from 'antd';\nimport { authService, User } from '../services/authService';\nimport { tokenManager } from '../services/api';\n\n// 认证状态类型\ninterface AuthState {\n  user: User | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  error: string | null;\n  lastVerified: number | null; // 上次验证时间戳\n  tokenRefreshInProgress: boolean; // 是否正在刷新token\n  networkError: boolean; // 是否存在网络错误\n}\n\n// 认证操作类型\ntype AuthAction =\n  | { type: 'AUTH_INIT' }\n  | { type: 'AUTH_SUCCESS'; payload: { user: User } }\n  | { type: 'AUTH_FAILURE'; payload: { error: string } }\n  | { type: 'AUTH_RESET' }\n  | { type: 'SET_LOADING'; payload: { isLoading: boolean } }\n  | { type: 'SET_NETWORK_ERROR'; payload: { networkError: boolean } }\n  | { type: 'TOKEN_REFRESH_START' }\n  | { type: 'TOKEN_REFRESH_END' };\n\n// 认证上下文类型\ninterface AuthContextType extends AuthState {\n  login: (username: string, password: string) => Promise<boolean>;\n  register: (username: string, email: string, password: string) => Promise<boolean>;\n  logout: () => Promise<void>;\n  refreshUser: () => Promise<void>;\n  verifySession: () => Promise<boolean>; // 新增：验证会话有效性\n}\n\n// 创建认证上下文\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\n// 初始状态\nconst initialState: AuthState = {\n  user: null,\n  isAuthenticated: false,\n  isLoading: true,\n  error: null,\n  lastVerified: null,\n  tokenRefreshInProgress: false,\n  networkError: false\n};\n\n// 认证状态reducer\nconst authReducer = (state: AuthState, action: AuthAction): AuthState => {\n  switch (action.type) {\n    case 'AUTH_INIT':\n      return {\n        ...state,\n        isLoading: true,\n        error: null,\n        networkError: false\n      };\n    case 'AUTH_SUCCESS':\n      return {\n        ...state,\n        user: action.payload.user,\n        isAuthenticated: true,\n        isLoading: false,\n        error: null,\n        lastVerified: Date.now(),\n        networkError: false\n      };\n    case 'AUTH_FAILURE':\n      return {\n        ...state,\n        user: null,\n        isAuthenticated: false,\n        isLoading: false,\n        error: action.payload.error,\n        lastVerified: Date.now()\n      };\n    case 'AUTH_RESET':\n      return {\n        ...initialState,\n        isLoading: false\n      };\n    case 'SET_LOADING':\n      return {\n        ...state,\n        isLoading: action.payload.isLoading\n      };\n    case 'SET_NETWORK_ERROR':\n      return {\n        ...state,\n        networkError: action.payload.networkError\n      };\n    case 'TOKEN_REFRESH_START':\n      return {\n        ...state,\n        tokenRefreshInProgress: true\n      };\n    case 'TOKEN_REFRESH_END':\n      return {\n        ...state,\n        tokenRefreshInProgress: false\n      };\n    default:\n      return state;\n  }\n};\n\n// 本地存储键\nconst USER_INFO_KEY = 'userInfo';\nconst AUTH_LAST_VERIFIED_KEY = 'auth_last_verified';\n\n// 认证提供者组件\ninterface AuthProviderProps {\n  children: ReactNode;\n}\n\nexport const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {\n  const [state, dispatch] = useReducer(authReducer, initialState);\n\n  // 验证会话有效性\n  const verifySession = async (): Promise<boolean> => {\n    // 如果没有token，直接返回false\n    const token = tokenManager.getToken();\n    if (!token) {\n      console.log('没有找到token，会话无效');\n      return false;\n    }\n\n    // 检查token格式是否有效\n    const tokenParts = token.split('.');\n    if (tokenParts.length !== 3) {\n      console.warn('token格式无效，清除认证状态');\n      await handleLogout(false);\n      return false;\n    }\n\n    // 如果正在刷新token，等待完成\n    if (state.tokenRefreshInProgress) {\n      console.log('token刷新进行中，使用当前认证状态');\n      return state.isAuthenticated;\n    }\n\n    // 检查token是否过期（通过解析JWT的payload）\n    try {\n      const payload = JSON.parse(atob(tokenParts[1]));\n      if (payload.exp && payload.exp * 1000 < Date.now()) {\n        console.warn('token已过期，清除认证状态');\n        await handleLogout(false);\n        return false;\n      }\n    } catch (e) {\n      console.warn('无法解析token payload:', e);\n      // 继续验证，让服务器决定token是否有效\n    }\n\n    // 检查上次验证时间，如果在5分钟内验证过，直接返回当前状态\n    const lastVerified = state.lastVerified || Number(localStorage.getItem(AUTH_LAST_VERIFIED_KEY)) || 0;\n    const now = Date.now();\n    const fiveMinutes = 5 * 60 * 1000;\n    \n    if (now - lastVerified < fiveMinutes && state.user) {\n      console.log('会话在5分钟内已验证，跳过验证，直接使用当前状态');\n      // 确保状态是已认证的\n      if (!state.isAuthenticated && state.user) {\n        console.log('状态不一致，更新认证状态为已认证');\n        dispatch({ type: 'AUTH_SUCCESS', payload: { user: state.user } });\n      }\n      return true;\n    }\n\n    // 开始验证token\n    console.log('开始验证token...');\n    dispatch({ type: 'TOKEN_REFRESH_START' });\n    \n    try {\n      console.log('验证会话有效性...');\n      const result = await authService.verifyToken();\n      \n      if (result.success && result.user) {\n        // 更新用户信息和验证时间\n        console.log('会话验证成功，更新用户信息');\n        dispatch({ type: 'AUTH_SUCCESS', payload: { user: result.user } });\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        return true;\n      } else if (result.networkError) {\n        // 网络错误时，如果有用户信息，保持认证状态\n        console.warn('网络错误，检查本地用户信息');\n        const storedUserInfo = localStorage.getItem(USER_INFO_KEY);\n        if (storedUserInfo) {\n          try {\n            const parsedUserInfo = JSON.parse(storedUserInfo);\n            console.log('使用本地存储的用户信息:', parsedUserInfo);\n            dispatch({ type: 'AUTH_SUCCESS', payload: { user: parsedUserInfo } });\n            dispatch({ type: 'SET_NETWORK_ERROR', payload: { networkError: true } });\n            return true;\n          } catch (e) {\n            console.error('解析本地用户信息失败:', e);\n          }\n        }\n        // 没有可用的用户信息，标记网络错误\n        dispatch({ type: 'SET_NETWORK_ERROR', payload: { networkError: true } });\n        message.error('网络连接错误，请检查网络连接');\n        return state.isAuthenticated; // 网络错误时保持当前状态\n      } else {\n        // 验证失败，清除状态\n        console.warn('会话验证失败，清除认证状态');\n        await handleLogout(false);\n        return false;\n      }\n    } catch (error) {\n      console.error('会话验证出错:', error);\n      \n      // 网络错误时不清除本地状态，但标记网络错误\n      if (error instanceof Error && error.message.includes('Network Error')) {\n        console.warn('网络错误，保持当前认证状态');\n        dispatch({ type: 'SET_NETWORK_ERROR', payload: { networkError: true } });\n        message.error('网络连接错误，请检查网络连接');\n        return state.isAuthenticated; // 网络错误时保持当前状态\n      }\n      \n      // 其他错误清除状态\n      console.warn('会话验证出错，清除认证状态');\n      await handleLogout(false);\n      return false;\n    } finally {\n      dispatch({ type: 'TOKEN_REFRESH_END' });\n    }\n  };\n\n  // 初始化认证状态\n  useEffect(() => {\n    const initAuth = async () => {\n      dispatch({ type: 'AUTH_INIT' });\n      \n      try {\n        // 检查localStorage中是否有token\n        if (tokenManager.isAuthenticated()) {\n          console.log('发现本地存储的token，正在初始化认证状态...');\n          \n          // 尝试从localStorage恢复用户信息\n          const storedUserInfo = localStorage.getItem(USER_INFO_KEY);\n          if (storedUserInfo) {\n            try {\n              const parsedUserInfo = JSON.parse(storedUserInfo);\n              console.log('从localStorage恢复用户信息:', parsedUserInfo);\n              \n              // 先设置用户信息，以便快速显示UI\n              dispatch({ \n                type: 'AUTH_SUCCESS', \n                payload: { user: parsedUserInfo } \n              });\n              \n              // 然后异步验证token有效性\n              verifySession().catch(error => {\n                console.error('会话验证失败:', error);\n              });\n            } catch (e) {\n              console.error('解析localStorage中的用户信息失败:', e);\n              dispatch({ \n                type: 'AUTH_FAILURE', \n                payload: { error: '用户信息解析失败' } \n              });\n            }\n          } else {\n            // 有token但没有用户信息，验证token\n            const verified = await verifySession();\n            if (!verified) {\n              dispatch({ \n                type: 'AUTH_FAILURE', \n                payload: { error: '会话已过期' } \n              });\n            }\n          }\n        } else {\n          console.log('未找到token，用户未登录');\n          dispatch({ type: 'AUTH_RESET' });\n        }\n      } catch (error) {\n        console.error('初始化认证时出错:', error);\n        dispatch({ \n          type: 'AUTH_FAILURE', \n          payload: { error: '认证初始化失败' } \n        });\n      }\n    };\n\n    initAuth();\n    \n    // 设置定期验证会话的定时器（每15分钟）\n    const sessionCheckInterval = setInterval(() => {\n      if (tokenManager.isAuthenticated() && state.user) {\n        console.log('定期验证会话...');\n        verifySession().catch(error => {\n          console.error('定期会话验证失败:', error);\n        });\n      }\n    }, 15 * 60 * 1000);\n    \n    // 监听存储事件，实现多标签页同步\n    const handleStorageChange = (event: StorageEvent) => {\n      if (event.key === 'auth_token' && !event.newValue) {\n        // 其他标签页删除了token，同步登出\n        console.log('检测到其他标签页登出，同步登出状态');\n        dispatch({ type: 'AUTH_RESET' });\n      }\n    };\n    \n    window.addEventListener('storage', handleStorageChange);\n    \n    return () => {\n      clearInterval(sessionCheckInterval);\n      window.removeEventListener('storage', handleStorageChange);\n    };\n  }, []);\n\n  // 处理登出逻辑\n  const handleLogout = async (callApi: boolean = true): Promise<void> => {\n    try {\n      if (callApi) {\n        // 调用后端登出API\n        await authService.logout().catch(error => {\n          console.warn('登出API调用失败:', error);\n        });\n      }\n    } finally {\n      // 无论API调用成功与否，都清除本地状态\n      tokenManager.removeToken();\n      localStorage.removeItem(USER_INFO_KEY);\n      localStorage.removeItem(AUTH_LAST_VERIFIED_KEY);\n      dispatch({ type: 'AUTH_RESET' });\n    }\n  };\n\n  // 登录方法\n  const login = async (username: string, password: string): Promise<boolean> => {\n    dispatch({ type: 'AUTH_INIT' });\n    \n    try {\n      const result = await authService.login({ username, password });\n      \n      if (result.success && result.data) {\n        // 登录成功，更新状态\n        dispatch({ \n          type: 'AUTH_SUCCESS', \n          payload: { user: result.data.user } \n        });\n        \n        // 保存用户信息到localStorage\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        \n        message.success('登录成功！');\n        return true;\n      } else {\n        // 登录失败，显示错误\n        dispatch({ \n          type: 'AUTH_FAILURE', \n          payload: { error: result.message || '登录失败' } \n        });\n        return false;\n      }\n    } catch (error: any) {\n      console.error('登录过程出错:', error);\n      \n      // 网络错误特殊处理\n      if (error.message && error.message.includes('Network Error')) {\n        dispatch({ \n          type: 'SET_NETWORK_ERROR', \n          payload: { networkError: true } \n        });\n        message.error('网络连接错误，请检查网络连接');\n      } else {\n        dispatch({ \n          type: 'AUTH_FAILURE', \n          payload: { error: '登录失败，请重试' } \n        });\n      }\n      \n      return false;\n    }\n  };\n\n  // 注册方法\n  const register = async (username: string, email: string, password: string): Promise<boolean> => {\n    dispatch({ type: 'AUTH_INIT' });\n    \n    try {\n      const result = await authService.register({ username, email, password });\n      \n      if (result.success && result.data) {\n        // 注册成功，更新状态\n        dispatch({ \n          type: 'AUTH_SUCCESS', \n          payload: { user: result.data.user } \n        });\n        \n        // 保存用户信息到localStorage\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.data.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n        \n        message.success('注册成功！');\n        return true;\n      } else {\n        // 注册失败，显示错误\n        dispatch({ \n          type: 'AUTH_FAILURE', \n          payload: { error: result.message || '注册失败' } \n        });\n        return false;\n      }\n    } catch (error: any) {\n      console.error('注册过程出错:', error);\n      \n      // 网络错误特殊处理\n      if (error.message && error.message.includes('Network Error')) {\n        dispatch({ \n          type: 'SET_NETWORK_ERROR', \n          payload: { networkError: true } \n        });\n        message.error('网络连接错误，请检查网络连接');\n      } else {\n        dispatch({ \n          type: 'AUTH_FAILURE', \n          payload: { error: '注册失败，请重试' } \n        });\n      }\n      \n      return false;\n    }\n  };\n\n  // 登出方法\n  const logout = async (): Promise<void> => {\n    await handleLogout(true);\n    message.success('已安全退出登录');\n  };\n\n  // 刷新用户信息\n  const refreshUser = async (): Promise<void> => {\n    if (!tokenManager.isAuthenticated() || !state.user) {\n      return;\n    }\n    \n    try {\n      const result = await authService.getProfile();\n      \n      if (result.success && result.user) {\n        // 更新用户信息\n        dispatch({ \n          type: 'AUTH_SUCCESS', \n          payload: { user: result.user } \n        });\n        \n        // 更新localStorage中的用户信息\n        localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.user));\n        localStorage.setItem(AUTH_LAST_VERIFIED_KEY, Date.now().toString());\n      }\n    } catch (error) {\n      console.error('刷新用户信息失败:', error);\n      \n      // 网络错误不清除状态\n      if (error instanceof Error && error.message.includes('Network Error')) {\n        dispatch({ \n          type: 'SET_NETWORK_ERROR', \n          payload: { networkError: true } \n        });\n        message.error('网络连接错误，请检查网络连接');\n      }\n    }\n  };\n\n  // 提供上下文值\n  const contextValue: AuthContextType = {\n    ...state,\n    login,\n    register,\n    logout,\n    refreshUser,\n    verifySession\n  };\n\n  return (\n    <AuthContext.Provider value={contextValue}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\n// 使用认证上下文的Hook\nexport const useAuth = (): AuthContextType => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}